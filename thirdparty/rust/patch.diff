diff --git a/Cargo.lock b/Cargo.lock
index 152689953b8..9af4681c4a6 100644
--- a/Cargo.lock
+++ b/Cargo.lock
@@ -520,6 +520,10 @@ name = "cfg-if"
 version = "1.0.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "baf1de4339761588bc0619e3cbc0120ee582ebb74b53b4efbf79117bd2da40fd"
+dependencies = [
+ "compiler_builtins",
+ "rustc-std-workspace-core",
+]
 
 [[package]]
 name = "chalk-derive"
@@ -2371,6 +2375,35 @@ dependencies = [
  "version_check",
 ]
 
+[[package]]
+name = "norostb_kernel"
+version = "0.1.0"
+dependencies = [
+ "compiler_builtins",
+ "rustc-std-workspace-core",
+]
+
+[[package]]
+name = "norostb_rt"
+version = "0.1.0"
+dependencies = [
+ "cfg-if 1.0.0",
+ "compiler_builtins",
+ "norostb_kernel",
+ "rustc-std-workspace-alloc",
+ "rustc-std-workspace-core",
+]
+
+[[package]]
+name = "norostb_rt_alloc"
+version = "0.1.0"
+dependencies = [
+ "compiler_builtins",
+ "norostb_kernel",
+ "rustc-std-workspace-alloc",
+ "rustc-std-workspace-core",
+]
+
 [[package]]
 name = "ntapi"
 version = "0.3.6"
@@ -4794,6 +4827,8 @@ dependencies = [
  "hermit-abi 0.2.0",
  "libc",
  "miniz_oxide",
+ "norostb_rt",
+ "norostb_rt_alloc",
  "object 0.26.2",
  "panic_abort",
  "panic_unwind",
diff --git a/Cargo.toml b/Cargo.toml
index cae48d79517..ff16e9b9ee6 100644
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -124,6 +124,7 @@ rustfmt-nightly = { path = "src/tools/rustfmt" }
 # See comments in `src/tools/rustc-workspace-hack/README.md` for what's going on
 # here
 rustc-workspace-hack = { path = 'src/tools/rustc-workspace-hack' }
+#slabmalloc = { git = "https://git.sr.ht/~demindiro/rust-slabmalloc", branch = "norost" }
 
 # See comments in `library/rustc-std-workspace-core/README.md` for what's going on
 # here
@@ -131,5 +132,9 @@ rustc-std-workspace-core = { path = 'library/rustc-std-workspace-core' }
 rustc-std-workspace-alloc = { path = 'library/rustc-std-workspace-alloc' }
 rustc-std-workspace-std = { path = 'library/rustc-std-workspace-std' }
 
+# No norostb packages are published to crates.io
+norostb_rt = { path = "../../norost/b/lib/rust/rt" }
+norostb_rt_alloc = { path = "../../norost/b/lib/rust/rt_alloc" }
+
 [patch."https://github.com/rust-lang/rust-clippy"]
 clippy_lints = { path = "src/tools/clippy/clippy_lints" }
diff --git a/compiler/rustc_target/src/spec/i686_unknown_none_norostbkernel.rs b/compiler/rustc_target/src/spec/i686_unknown_none_norostbkernel.rs
new file mode 100644
index 00000000000..7d5e1b48d81
--- /dev/null
+++ b/compiler/rustc_target/src/spec/i686_unknown_none_norostbkernel.rs
@@ -0,0 +1,19 @@
+use crate::spec::{Target, TargetOptions};
+
+pub fn target() -> Target {
+    Target {
+        llvm_target: "i686-unknown-none".into(),
+        pointer_width: 32,
+        data_layout:
+            "e-m:e-p:32:32-p270:32:32-p271:32:32-p272:64:64-f64:32:64-f80:32-n8:16:32-S128".into(),
+        arch: "x86".into(),
+        options: TargetOptions {
+            cpu: "i686".into(),
+            max_atomic_width: Some(32),
+            features:
+                "-mmx,-sse,-sse2,-sse3,-ssse3,-sse4.1,-sse4.2,-3dnow,-3dnowa,-avx,-avx2,+soft-float"
+                    .into(),
+            ..super::norostb_kernel_base::opts()
+        },
+    }
+}
diff --git a/compiler/rustc_target/src/spec/mod.rs b/compiler/rustc_target/src/spec/mod.rs
index 92678aed5b1..15c65df16c8 100644
--- a/compiler/rustc_target/src/spec/mod.rs
+++ b/compiler/rustc_target/src/spec/mod.rs
@@ -73,6 +73,8 @@
 mod linux_uclibc_base;
 mod msvc_base;
 mod netbsd_base;
+mod norostb_base;
+mod norostb_kernel_base;
 mod openbsd_base;
 mod redox_base;
 mod solaris_base;
@@ -1023,6 +1025,10 @@ fn $module() {
     ("x86_64-unknown-none", x86_64_unknown_none),
 
     ("mips64-openwrt-linux-musl", mips64_openwrt_linux_musl),
+
+    ("x86_64-unknown-norostb", x86_64_unknown_norostb),
+    ("i686-unknown-none-norostbkernel", i686_unknown_none_norostbkernel),
+    ("x86_64-unknown-none-norostbkernel", x86_64_unknown_none_norostbkernel),
 }
 
 /// Warnings encountered when parsing the target `json`.
diff --git a/compiler/rustc_target/src/spec/norostb_base.rs b/compiler/rustc_target/src/spec/norostb_base.rs
new file mode 100644
index 00000000000..381bf54beed
--- /dev/null
+++ b/compiler/rustc_target/src/spec/norostb_base.rs
@@ -0,0 +1,15 @@
+use crate::spec::{LinkerFlavor, LldFlavor, PanicStrategy, TargetOptions};
+
+pub fn opts() -> TargetOptions {
+    TargetOptions {
+        os: "norostb".into(),
+        executables: true,
+        // TODO figure out why rust-lld is missing from stage2 folder and/or
+        // why the one in $PATH isn't used.
+        //linker: Some("rust-lld".into()),
+        linker: Some("ld.lld".into()),
+        linker_flavor: LinkerFlavor::Lld(LldFlavor::Ld),
+        panic_strategy: PanicStrategy::Abort,
+        ..Default::default()
+    }
+}
diff --git a/compiler/rustc_target/src/spec/norostb_kernel_base.rs b/compiler/rustc_target/src/spec/norostb_kernel_base.rs
new file mode 100644
index 00000000000..f1daa1c5e8f
--- /dev/null
+++ b/compiler/rustc_target/src/spec/norostb_kernel_base.rs
@@ -0,0 +1,16 @@
+use crate::spec::{LinkerFlavor, LldFlavor, PanicStrategy, TargetOptions};
+
+pub fn opts() -> TargetOptions {
+    TargetOptions {
+        executables: true,
+        static_position_independent_executables: true,
+        disable_redzone: true,
+        // TODO figure out why rust-lld is missing from stage2 folder and/or
+        // why the one in $PATH isn't used.
+        //linker: Some("rust-lld".into()),
+        linker: Some("ld.lld".into()),
+        linker_flavor: LinkerFlavor::Lld(LldFlavor::Ld),
+        panic_strategy: PanicStrategy::Abort,
+        ..Default::default()
+    }
+}
diff --git a/compiler/rustc_target/src/spec/x86_64_unknown_none_norostbkernel.rs b/compiler/rustc_target/src/spec/x86_64_unknown_none_norostbkernel.rs
new file mode 100644
index 00000000000..2e71cc9d9a6
--- /dev/null
+++ b/compiler/rustc_target/src/spec/x86_64_unknown_none_norostbkernel.rs
@@ -0,0 +1,19 @@
+use crate::spec::{Target, TargetOptions};
+
+pub fn target() -> Target {
+    Target {
+        llvm_target: "x86_64-unknown-none".into(),
+        pointer_width: 64,
+        data_layout: "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128"
+            .into(),
+        arch: "x86_64".into(),
+        options: TargetOptions {
+            cpu: "x86-64".to_string(),
+            max_atomic_width: Some(64),
+            features:
+                "-mmx,-sse,-sse2,-sse3,-ssse3,-sse4.1,-sse4.2,-3dnow,-3dnowa,-avx,-avx2,+soft-float"
+                    .into(),
+            ..super::norostb_kernel_base::opts()
+        },
+    }
+}
diff --git a/compiler/rustc_target/src/spec/x86_64_unknown_norostb.rs b/compiler/rustc_target/src/spec/x86_64_unknown_norostb.rs
new file mode 100644
index 00000000000..4bed0d09bb3
--- /dev/null
+++ b/compiler/rustc_target/src/spec/x86_64_unknown_norostb.rs
@@ -0,0 +1,18 @@
+use crate::spec::{Target, TargetOptions};
+
+pub fn target() -> Target {
+    Target {
+        llvm_target: "x86_64-unknown-none".into(),
+        pointer_width: 64,
+        data_layout: "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128"
+            .into(),
+        arch: "x86_64".into(),
+        options: TargetOptions {
+            cpu: "x86-64".into(),
+            disable_redzone: true,
+            features: "-mmx,-sse,+soft-float".into(),
+            max_atomic_width: Some(64),
+            ..super::norostb_base::opts()
+        },
+    }
+}
diff --git a/library/panic_abort/src/lib.rs b/library/panic_abort/src/lib.rs
index 5c5632a9d01..26939b2b401 100644
--- a/library/panic_abort/src/lib.rs
+++ b/library/panic_abort/src/lib.rs
@@ -44,6 +44,7 @@ unsafe fn abort() -> ! {
             }
         } else if #[cfg(any(target_os = "hermit",
                             target_os = "solid_asp3",
+                            target_os = "norostb",
                             all(target_vendor = "fortanix", target_env = "sgx")
         ))] {
             unsafe fn abort() -> ! {
diff --git a/library/panic_unwind/src/lib.rs b/library/panic_unwind/src/lib.rs
index 7f05c82ac28..0ccf6a783c1 100644
--- a/library/panic_unwind/src/lib.rs
+++ b/library/panic_unwind/src/lib.rs
@@ -43,6 +43,9 @@
         // L4Re is unix family but does not yet support unwinding.
         #[path = "dummy.rs"]
         mod real_imp;
+    } else if #[cfg(target_os = "norostb")] {
+        #[path = "norostb.rs"]
+        mod real_imp;
     } else if #[cfg(target_env = "msvc")] {
         #[path = "seh.rs"]
         mod real_imp;
diff --git a/library/panic_unwind/src/norostb.rs b/library/panic_unwind/src/norostb.rs
new file mode 100644
index 00000000000..1213919ab9a
--- /dev/null
+++ b/library/panic_unwind/src/norostb.rs
@@ -0,0 +1,20 @@
+//! Unwinding for *norostb* target.
+//!
+//! Right now we don't support this, so this is just stubs.
+
+use alloc::boxed::Box;
+use core::any::Any;
+
+pub unsafe fn cleanup(_ptr: *mut u8) -> Box<dyn Any + Send> {
+    extern "C" {
+        pub fn __rust_abort() -> !;
+    }
+    __rust_abort();
+}
+
+pub unsafe fn panic(_data: Box<dyn Any + Send>) -> u32 {
+    extern "C" {
+        pub fn __rust_abort() -> !;
+    }
+    __rust_abort();
+}
diff --git a/library/std/Cargo.toml b/library/std/Cargo.toml
index dd9b035e86d..097ef09a241 100644
--- a/library/std/Cargo.toml
+++ b/library/std/Cargo.toml
@@ -47,6 +47,10 @@ hermit-abi = { version = "0.2.0", features = ['rustc-dep-of-std'] }
 [target.wasm32-wasi.dependencies]
 wasi = { version = "0.11.0", features = ['rustc-dep-of-std'], default-features = false }
 
+[target.'cfg(target_os = "norostb")'.dependencies]
+norostb_rt = { version = "*", default-features = false, features =["rustc-dep-of-std"] }
+norostb_rt_alloc = { version = "*", default-features = false, features =["rustc-dep-of-std"] }
+
 [features]
 backtrace = [
   "gimli-symbolize",
diff --git a/library/std/build.rs b/library/std/build.rs
index 43168e77296..830bfb78c43 100644
--- a/library/std/build.rs
+++ b/library/std/build.rs
@@ -29,6 +29,7 @@ fn main() {
         || target.contains("asmjs")
         || target.contains("espidf")
         || target.contains("solid")
+        || target.contains("norostb")
     {
         // These platforms don't have any special requirements.
     } else {
diff --git a/library/std/src/lib.rs b/library/std/src/lib.rs
index 2628afd4237..9c4a22bc6f2 100644
--- a/library/std/src/lib.rs
+++ b/library/std/src/lib.rs
@@ -231,6 +231,8 @@
 #![feature(allow_internal_unstable)]
 #![feature(arbitrary_self_types)]
 #![feature(array_error_internals)]
+#![feature(asm_const)]
+#![feature(asm_sym)]
 #![feature(assert_matches)]
 #![feature(associated_type_bounds)]
 #![feature(async_iterator)]
@@ -249,6 +251,7 @@
 #![feature(char_internals)]
 #![feature(concat_bytes)]
 #![feature(concat_idents)]
+#![feature(const_btree_new)]
 #![feature(const_fn_floating_point_arithmetic)]
 #![feature(const_fn_fn_ptr_basics)]
 #![feature(const_fn_trait_bound)]
@@ -300,6 +303,7 @@
 #![feature(min_specialization)]
 #![feature(mixed_integer_ops)]
 #![feature(must_not_suspend)]
+#![feature(naked_functions)]
 #![feature(needs_panic_runtime)]
 #![feature(negative_impls)]
 #![feature(never_type)]
@@ -316,6 +320,7 @@
 #![feature(prelude_import)]
 #![feature(ptr_as_uninit)]
 #![feature(ptr_internals)]
+#![feature(ptr_metadata)]
 #![feature(rustc_attrs)]
 #![feature(rustc_private)]
 #![feature(saturating_int_impl)]
diff --git a/library/std/src/os/mod.rs b/library/std/src/os/mod.rs
index 90c30313dbb..1051aee1636 100644
--- a/library/std/src/os/mod.rs
+++ b/library/std/src/os/mod.rs
@@ -131,6 +131,8 @@ pub mod windows {}
 pub mod macos;
 #[cfg(target_os = "netbsd")]
 pub mod netbsd;
+#[cfg(target_os = "norostb")]
+pub mod norostb;
 #[cfg(target_os = "openbsd")]
 pub mod openbsd;
 #[cfg(target_os = "redox")]
diff --git a/library/std/src/os/norostb/ffi.rs b/library/std/src/os/norostb/ffi.rs
new file mode 100644
index 00000000000..17243a4af12
--- /dev/null
+++ b/library/std/src/os/norostb/ffi.rs
@@ -0,0 +1,7 @@
+#![unstable(feature = "norostb", issue = "none")]
+
+#[path = "../unix/ffi/os_str.rs"]
+mod os_str;
+
+#[unstable(feature = "norostb", issue = "none")]
+pub use self::os_str::{OsStrExt, OsStringExt};
diff --git a/library/std/src/os/norostb/io.rs b/library/std/src/os/norostb/io.rs
new file mode 100644
index 00000000000..26f5309308e
--- /dev/null
+++ b/library/std/src/os/norostb/io.rs
@@ -0,0 +1,34 @@
+use crate::sys_common::{AsInner, FromInner, IntoInner};
+use crate::{fs, sys};
+
+pub type Handle = u32;
+
+pub trait AsHandle {
+    fn as_handle(&self) -> Handle;
+}
+
+pub trait IntoHandle {
+    fn into_handle(self) -> Handle;
+}
+
+pub trait FromHandle {
+    unsafe fn from_handle(handle: Handle) -> Self;
+}
+
+impl AsHandle for fs::File {
+    fn as_handle(&self) -> Handle {
+        self.as_inner().0.as_raw()
+    }
+}
+
+impl IntoHandle for fs::File {
+    fn into_handle(self) -> Handle {
+        self.into_inner().0.into_raw()
+    }
+}
+
+impl FromHandle for fs::File {
+    unsafe fn from_handle(handle: Handle) -> Self {
+        Self::from_inner(sys::fs::File(norostb_rt::table::Object::from_raw(handle)))
+    }
+}
diff --git a/library/std/src/os/norostb/mod.rs b/library/std/src/os/norostb/mod.rs
new file mode 100644
index 00000000000..a06c561b91c
--- /dev/null
+++ b/library/std/src/os/norostb/mod.rs
@@ -0,0 +1,10 @@
+#![unstable(feature = "norostb", issue = "none")]
+
+pub mod ffi;
+pub mod io;
+
+pub mod prelude {
+    use super::*;
+    pub use ffi::{OsStrExt, OsStringExt};
+    pub use io::{AsHandle, FromHandle, Handle, IntoHandle};
+}
diff --git a/library/std/src/sys/mod.rs b/library/std/src/sys/mod.rs
index 167c918c94c..dbfba32bd66 100644
--- a/library/std/src/sys/mod.rs
+++ b/library/std/src/sys/mod.rs
@@ -46,6 +46,9 @@
     } else if #[cfg(all(target_vendor = "fortanix", target_env = "sgx"))] {
         mod sgx;
         pub use self::sgx::*;
+    } else if #[cfg(target_os = "norostb")] {
+        mod norostb;
+        pub use self::norostb::*;
     } else {
         mod unsupported;
         pub use self::unsupported::*;
diff --git a/library/std/src/sys/norostb/alloc.rs b/library/std/src/sys/norostb/alloc.rs
new file mode 100644
index 00000000000..70a82ee098f
--- /dev/null
+++ b/library/std/src/sys/norostb/alloc.rs
@@ -0,0 +1,20 @@
+use crate::alloc::{GlobalAlloc, Layout, System};
+
+macro_rules! imp {
+    ($fn:ident($($args:ident : $ty:ty),*) -> $ret:ty) => {
+        #[inline]
+        unsafe fn $fn(&self, $($args:$ty),*) -> $ret {
+            unsafe {
+                norostb_rt_alloc::Allocator.$fn($($args),*)
+            }
+        }
+    };
+}
+
+#[stable(feature = "alloc_system_type", since = "1.28.0")]
+unsafe impl GlobalAlloc for System {
+    imp!(alloc(layout: Layout) -> *mut u8);
+    imp!(alloc_zeroed(layout: Layout) -> *mut u8);
+    imp!(dealloc(ptr: *mut u8, layout: Layout) -> ());
+    imp!(realloc(ptr: *mut u8, layout: Layout, new_size: usize) -> *mut u8);
+}
diff --git a/library/std/src/sys/norostb/args.rs b/library/std/src/sys/norostb/args.rs
new file mode 100644
index 00000000000..dc96c9d5fdd
--- /dev/null
+++ b/library/std/src/sys/norostb/args.rs
@@ -0,0 +1,66 @@
+use crate::ffi::{OsStr, OsString};
+use crate::io;
+use crate::os::norostb::ffi::{OsStrExt, OsStringExt};
+
+use norostb_rt::args;
+
+#[derive(Debug)]
+pub struct Args(args::Args);
+
+impl Iterator for Args {
+    type Item = OsString;
+
+    fn next(&mut self) -> Option<Self::Item> {
+        self.0.next().map(OsStr::from_bytes).map(Into::into)
+    }
+}
+
+impl ExactSizeIterator for Args {
+    fn len(&self) -> usize {
+        self.0.len()
+    }
+}
+
+impl DoubleEndedIterator for Args {
+    fn next_back(&mut self) -> Option<Self::Item> {
+        self.0.next_back().map(OsStr::from_bytes).map(Into::into)
+    }
+}
+
+#[derive(Debug)]
+pub struct Env(args::Env);
+
+impl Iterator for Env {
+    type Item = (OsString, OsString);
+
+    fn next(&mut self) -> Option<Self::Item> {
+        self.0.next().map(|(key, val)| {
+            (OsString::from_vec(key.into_owned()), OsString::from_vec(val.into_owned()))
+        })
+    }
+}
+
+pub fn args() -> Args {
+    Args(args::Args::new())
+}
+
+pub fn env() -> Env {
+    Env(args::Env::new())
+}
+
+pub fn getenv(key: &OsStr) -> Option<OsString> {
+    args::Env::get(OsStr::as_bytes(key)).map(|val| OsString::from_vec(val.into_owned()))
+}
+
+pub fn setenv(key: &OsStr, value: &OsStr) -> io::Result<()> {
+    let f = |v| Vec::from(OsStr::as_bytes(v)).into();
+    args::Env::try_insert(f(key), f(value))
+        .map(|_| ())
+        .map_err(|_| io::const_io_error!(io::ErrorKind::OutOfMemory, "out of memory"))
+}
+
+pub fn unsetenv(key: &OsStr) -> io::Result<()> {
+    // Removing non-existent env variables is valid in stdlib.
+    let _ = args::Env::remove(OsStr::as_bytes(key));
+    Ok(())
+}
diff --git a/library/std/src/sys/norostb/common.rs b/library/std/src/sys/norostb/common.rs
new file mode 100644
index 00000000000..78eaf61d8b4
--- /dev/null
+++ b/library/std/src/sys/norostb/common.rs
@@ -0,0 +1,44 @@
+use crate::io as std_io;
+
+pub mod memchr {
+    pub use core::slice::memchr::{memchr, memrchr};
+}
+
+// This is not necessarily correct. May want to consider making it part of the
+// spec definition?
+use crate::os::raw::c_char;
+
+pub fn unsupported<T>() -> std_io::Result<T> {
+    Err(unsupported_err())
+}
+
+pub fn unsupported_err() -> std_io::Error {
+    std_io::const_io_error!(
+        std_io::ErrorKind::Unsupported,
+        "operation not supported on this platform",
+    )
+}
+
+pub fn decode_error_kind(_code: i32) -> crate::io::ErrorKind {
+    crate::io::ErrorKind::Uncategorized
+}
+
+pub fn abort_internal() -> ! {
+    super::os::exit(i32::MAX)
+}
+
+pub fn hashmap_random_keys() -> (u64, u64) {
+    (1, 2)
+}
+
+pub unsafe fn strlen(mut s: *const c_char) -> usize {
+    // SAFETY: The caller must guarantee `s` points to a valid 0-terminated string.
+    unsafe {
+        let mut n = 0;
+        while *s != 0 {
+            n += 1;
+            s = s.offset(1);
+        }
+        n
+    }
+}
diff --git a/library/std/src/sys/norostb/condvar.rs b/library/std/src/sys/norostb/condvar.rs
new file mode 100644
index 00000000000..35d12a69c8a
--- /dev/null
+++ b/library/std/src/sys/norostb/condvar.rs
@@ -0,0 +1,32 @@
+use crate::sys::mutex::Mutex;
+use crate::time::Duration;
+
+pub struct Condvar {}
+
+pub type MovableCondvar = Condvar;
+
+impl Condvar {
+    pub const fn new() -> Condvar {
+        Condvar {}
+    }
+
+    #[inline]
+    pub unsafe fn init(&mut self) {}
+
+    #[inline]
+    pub unsafe fn notify_one(&self) {}
+
+    #[inline]
+    pub unsafe fn notify_all(&self) {}
+
+    pub unsafe fn wait(&self, _mutex: &Mutex) {
+        panic!("condvar wait not supported")
+    }
+
+    pub unsafe fn wait_timeout(&self, _mutex: &Mutex, _dur: Duration) -> bool {
+        panic!("condvar wait not supported");
+    }
+
+    #[inline]
+    pub unsafe fn destroy(&self) {}
+}
diff --git a/library/std/src/sys/norostb/env.rs b/library/std/src/sys/norostb/env.rs
new file mode 100644
index 00000000000..d2efec506c5
--- /dev/null
+++ b/library/std/src/sys/norostb/env.rs
@@ -0,0 +1,9 @@
+pub mod os {
+    pub const FAMILY: &str = "";
+    pub const OS: &str = "";
+    pub const DLL_PREFIX: &str = "";
+    pub const DLL_SUFFIX: &str = "";
+    pub const DLL_EXTENSION: &str = "";
+    pub const EXE_SUFFIX: &str = "";
+    pub const EXE_EXTENSION: &str = "";
+}
diff --git a/library/std/src/sys/norostb/fs.rs b/library/std/src/sys/norostb/fs.rs
new file mode 100644
index 00000000000..3749c8709a9
--- /dev/null
+++ b/library/std/src/sys/norostb/fs.rs
@@ -0,0 +1,313 @@
+use super::cvt_err;
+/// ## Path format
+///
+/// ```
+/// table/[path]
+/// ```
+///
+/// ### Examples
+///
+/// ```
+/// pci
+/// pci/
+/// pci/vendor-id:1234,device-id:1111
+/// pci/vendor-id:1234,device-id:1111/8
+/// pci//8
+/// ```
+use crate::ffi::OsString;
+use crate::hash::Hash;
+use crate::io::{self, IoSlice, IoSliceMut, ReadBuf, SeekFrom};
+use crate::os::norostb::prelude::*;
+use crate::path::{Path, PathBuf};
+use crate::sys::time::SystemTime;
+use crate::sys::unsupported;
+use crate::sys_common::AsInner;
+use norostb_rt::{io as rt_io, table::Object};
+
+#[derive(Debug)]
+pub struct File(pub(crate) Object);
+
+#[derive(Clone, Debug)]
+pub enum FileAttr {}
+
+#[derive(Debug)]
+pub struct ReadDir(rt_io::Query);
+
+#[derive(Clone, Debug)]
+pub struct DirEntry(OsString);
+
+#[derive(Clone, Debug)]
+pub struct OpenOptions {
+    create: bool,
+}
+
+#[derive(Clone, Debug, PartialEq, Eq)]
+pub struct FilePermissions(());
+
+#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
+pub enum FileType {
+    Object,
+}
+
+#[derive(Debug)]
+pub struct DirBuilder {}
+
+impl FileAttr {
+    pub fn size(&self) -> u64 {
+        match self {
+            _ => unreachable!(),
+        }
+    }
+
+    pub fn perm(&self) -> FilePermissions {
+        FilePermissions(())
+    }
+
+    pub fn file_type(&self) -> FileType {
+        FileType::Object
+    }
+
+    pub fn modified(&self) -> io::Result<SystemTime> {
+        unsupported()
+    }
+
+    pub fn accessed(&self) -> io::Result<SystemTime> {
+        unsupported()
+    }
+
+    pub fn created(&self) -> io::Result<SystemTime> {
+        unsupported()
+    }
+}
+
+impl FilePermissions {
+    pub fn readonly(&self) -> bool {
+        false
+    }
+
+    pub fn set_readonly(&mut self, _readonly: bool) {}
+}
+
+impl FileType {
+    pub fn is_dir(&self) -> bool {
+        match self {
+            Self::Object => false,
+        }
+    }
+
+    pub fn is_file(&self) -> bool {
+        match self {
+            Self::Object => true,
+        }
+    }
+
+    pub fn is_symlink(&self) -> bool {
+        match self {
+            Self::Object => false,
+        }
+    }
+}
+
+impl Iterator for ReadDir {
+    type Item = io::Result<DirEntry>;
+
+    fn next(&mut self) -> Option<io::Result<DirEntry>> {
+        self.0.next().map(|path| Ok(DirEntry(OsString::from_vec(path))))
+    }
+}
+
+impl DirEntry {
+    pub fn path(&self) -> PathBuf {
+        self.0.clone().into()
+    }
+
+    pub fn file_name(&self) -> OsString {
+        // TODO this isn't quite accurate.
+        self.0.clone().into()
+    }
+
+    pub fn metadata(&self) -> io::Result<FileAttr> {
+        unsupported()
+    }
+
+    pub fn file_type(&self) -> io::Result<FileType> {
+        unsupported()
+    }
+}
+
+impl OpenOptions {
+    pub fn new() -> OpenOptions {
+        OpenOptions { create: false }
+    }
+
+    pub fn read(&mut self, _read: bool) {}
+    pub fn write(&mut self, _write: bool) {}
+    pub fn append(&mut self, _append: bool) {}
+    pub fn truncate(&mut self, _truncate: bool) {}
+    pub fn create(&mut self, create: bool) {
+        self.create = create;
+    }
+    pub fn create_new(&mut self, create_new: bool) {
+        self.create = create_new;
+    }
+}
+
+impl File {
+    pub fn open(path: &Path, opts: &OpenOptions) -> io::Result<File> {
+        let root = rt_io::file_root().ok_or(super::ERR_UNSET)?;
+        if opts.create { root.create(path_inner(path)) } else { root.open(path_inner(path)) }
+            .map(File)
+            .map_err(cvt_err)
+    }
+
+    pub fn file_attr(&self) -> io::Result<FileAttr> {
+        unsupported()
+    }
+
+    pub fn fsync(&self) -> io::Result<()> {
+        unsupported()
+    }
+
+    pub fn datasync(&self) -> io::Result<()> {
+        unsupported()
+    }
+
+    pub fn truncate(&self, _size: u64) -> io::Result<()> {
+        unsupported()
+    }
+
+    pub fn read(&self, buf: &mut [u8]) -> io::Result<usize> {
+        self.0.read(buf).map_err(cvt_err)
+    }
+
+    pub fn read_vectored(&self, _bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {
+        unsupported()
+    }
+
+    pub fn is_read_vectored(&self) -> bool {
+        false
+    }
+
+    pub fn read_buf(&self, buf: &mut ReadBuf<'_>) -> io::Result<()> {
+        // SAFETY: we don't deinitialize any part of the buffer
+        let s = unsafe { buf.unfilled_mut() };
+        let len = self.0.read_uninit(s).map_err(cvt_err)?;
+        // SAFETY: the kernel has initialized `len` bytes.
+        unsafe {
+            buf.assume_init(buf.filled().len() + len);
+        }
+        buf.add_filled(len);
+        Ok(())
+    }
+
+    pub fn write(&self, buf: &[u8]) -> io::Result<usize> {
+        self.0.write(buf).map_err(cvt_err)
+    }
+
+    pub fn write_vectored(&self, _bufs: &[IoSlice<'_>]) -> io::Result<usize> {
+        unsupported()
+    }
+
+    pub fn is_write_vectored(&self) -> bool {
+        false
+    }
+
+    pub fn flush(&self) -> io::Result<()> {
+        // TODO
+        Ok(())
+    }
+
+    pub fn seek(&self, pos: SeekFrom) -> io::Result<u64> {
+        let pos = match pos {
+            SeekFrom::Start(n) => rt_io::SeekFrom::Start(n),
+            SeekFrom::Current(n) => rt_io::SeekFrom::Current(n),
+            SeekFrom::End(n) => rt_io::SeekFrom::End(n),
+        };
+        self.0.seek(pos).map_err(cvt_err)
+    }
+
+    pub fn duplicate(&self) -> io::Result<File> {
+        self.0.duplicate().map_err(cvt_err).map(Self)
+    }
+
+    pub fn set_permissions(&self, _perm: FilePermissions) -> io::Result<()> {
+        unsupported()
+    }
+}
+
+impl DirBuilder {
+    pub fn new() -> DirBuilder {
+        DirBuilder {}
+    }
+
+    pub fn mkdir(&self, _p: &Path) -> io::Result<()> {
+        unsupported()
+    }
+}
+
+pub fn readdir(path: &Path) -> io::Result<ReadDir> {
+    rt_io::file_root()
+        .ok_or(super::ERR_UNSET)?
+        .query(path_inner(path))
+        .map(ReadDir)
+        .map_err(cvt_err)
+}
+
+pub fn unlink(_p: &Path) -> io::Result<()> {
+    unsupported()
+}
+
+pub fn rename(_old: &Path, _new: &Path) -> io::Result<()> {
+    unsupported()
+}
+
+pub fn set_perm(_p: &Path, _perm: FilePermissions) -> io::Result<()> {
+    unsupported()
+}
+
+pub fn rmdir(_p: &Path) -> io::Result<()> {
+    unsupported()
+}
+
+pub fn remove_dir_all(_path: &Path) -> io::Result<()> {
+    unsupported()
+}
+
+pub fn try_exists(path: &Path) -> io::Result<bool> {
+    readdir(path).map(|mut q| q.next().is_some())
+}
+
+pub fn readlink(_p: &Path) -> io::Result<PathBuf> {
+    // Symlinks are not supported at all
+    // UNIX returns "InvalidInput" which is rather confusing, so let's not do the same.
+    Err(io::const_io_error!(io::ErrorKind::Uncategorized, "not a symlnk"))
+}
+
+pub fn symlink(_original: &Path, _link: &Path) -> io::Result<()> {
+    unsupported()
+}
+
+pub fn link(_src: &Path, _dst: &Path) -> io::Result<()> {
+    unsupported()
+}
+
+pub fn stat(_path: &Path) -> io::Result<FileAttr> {
+    unsupported()
+}
+
+pub fn lstat(path: &Path) -> io::Result<FileAttr> {
+    stat(path)
+}
+
+pub fn canonicalize(_p: &Path) -> io::Result<PathBuf> {
+    unsupported()
+}
+
+pub fn copy(_from: &Path, _to: &Path) -> io::Result<u64> {
+    unsupported()
+}
+
+/// Get a reference to the underlying `[u8]` of a [`Path`].
+fn path_inner(path: &Path) -> &[u8] {
+    &path.as_os_str().as_inner().inner
+}
diff --git a/library/std/src/sys/norostb/io.rs b/library/std/src/sys/norostb/io.rs
new file mode 100644
index 00000000000..d5f475b4310
--- /dev/null
+++ b/library/std/src/sys/norostb/io.rs
@@ -0,0 +1,47 @@
+use crate::mem;
+
+#[derive(Copy, Clone)]
+pub struct IoSlice<'a>(&'a [u8]);
+
+impl<'a> IoSlice<'a> {
+    #[inline]
+    pub fn new(buf: &'a [u8]) -> IoSlice<'a> {
+        IoSlice(buf)
+    }
+
+    #[inline]
+    pub fn advance(&mut self, n: usize) {
+        self.0 = &self.0[n..]
+    }
+
+    #[inline]
+    pub fn as_slice(&self) -> &[u8] {
+        self.0
+    }
+}
+
+pub struct IoSliceMut<'a>(&'a mut [u8]);
+
+impl<'a> IoSliceMut<'a> {
+    #[inline]
+    pub fn new(buf: &'a mut [u8]) -> IoSliceMut<'a> {
+        IoSliceMut(buf)
+    }
+
+    #[inline]
+    pub fn advance(&mut self, n: usize) {
+        let slice = mem::replace(&mut self.0, &mut []);
+        let (_, remaining) = slice.split_at_mut(n);
+        self.0 = remaining;
+    }
+
+    #[inline]
+    pub fn as_slice(&self) -> &[u8] {
+        self.0
+    }
+
+    #[inline]
+    pub fn as_mut_slice(&mut self) -> &mut [u8] {
+        self.0
+    }
+}
diff --git a/library/std/src/sys/norostb/mod.rs b/library/std/src/sys/norostb/mod.rs
new file mode 100644
index 00000000000..6d692d70ba2
--- /dev/null
+++ b/library/std/src/sys/norostb/mod.rs
@@ -0,0 +1,78 @@
+#![deny(unsafe_op_in_unsafe_fn)]
+
+pub mod alloc;
+pub mod args;
+#[path = "../unix/cmath.rs"]
+pub mod cmath;
+pub mod condvar;
+pub mod env;
+pub mod fs;
+pub mod io;
+pub mod mutex;
+pub mod net;
+pub mod os;
+#[path = "../unix/os_str.rs"]
+pub mod os_str;
+#[path = "../unix/path.rs"]
+pub mod path;
+pub mod pipe;
+pub mod process;
+pub mod rwlock;
+pub mod stdio;
+pub mod thread;
+#[cfg(target_thread_local)]
+pub mod thread_local_dtor;
+pub mod thread_local_key;
+pub mod time;
+
+mod common;
+pub use common::*;
+
+// This function is needed by the panic runtime. The symbol is named in
+// pre-link args for the target specification, so keep that in sync.
+#[cfg(not(test))]
+#[no_mangle]
+// NB. used by both libunwind and libpanic_abort
+pub extern "C" fn __rust_abort() {
+    abort_internal();
+}
+
+/// # Safety
+///
+/// Must be called only once during runtime initialization.
+///
+/// # Note
+///
+/// This is not guaranteed to run, for example when Rust code is called externally.
+pub unsafe fn init(_: isize, _: *const *const u8) {
+    // FIXME this is not guaranteed to run.
+    unsafe {
+        stdio::init();
+    }
+}
+
+/// # Safety
+///
+/// Must be called only once during runtime cleanup.
+///
+/// # Note
+///
+/// This is not guaranteed to run, for example when Rust code is called externally.
+pub unsafe fn cleanup() {}
+
+fn cvt_err(err: norostb_rt::Error) -> crate::io::Error {
+    use crate::io::{const_io_error, ErrorKind};
+    use norostb_rt::Error;
+    match err {
+        Error::Unknown => const_io_error!(ErrorKind::Uncategorized, "uncategorized error"),
+        Error::InvalidOperation => const_io_error!(ErrorKind::Unsupported, "invalid operation"),
+        Error::DoesNotExist => const_io_error!(ErrorKind::NotFound, "does not exist"),
+        Error::AlreadyExists => const_io_error!(ErrorKind::AlreadyExists, "already exists"),
+        Error::Cancelled => const_io_error!(ErrorKind::Uncategorized, "cancelled"),
+        Error::CantCreateObject => const_io_error!(ErrorKind::InvalidInput, "can't create object"),
+        Error::InvalidObject => const_io_error!(ErrorKind::InvalidInput, "invalid object"),
+    }
+}
+
+const ERR_UNSET: crate::io::Error =
+    crate::io::const_io_error!(crate::io::ErrorKind::Uncategorized, "handle is not set");
diff --git a/library/std/src/sys/norostb/mutex.rs b/library/std/src/sys/norostb/mutex.rs
new file mode 100644
index 00000000000..b3203c16c50
--- /dev/null
+++ b/library/std/src/sys/norostb/mutex.rs
@@ -0,0 +1,61 @@
+use crate::cell::Cell;
+
+pub struct Mutex {
+    // This platform has no threads, so we can use a Cell here.
+    locked: Cell<bool>,
+}
+
+pub type MovableMutex = Mutex;
+
+unsafe impl Send for Mutex {}
+unsafe impl Sync for Mutex {} // no threads on this platform
+
+impl Mutex {
+    pub const fn new() -> Mutex {
+        Mutex { locked: Cell::new(false) }
+    }
+
+    #[inline]
+    pub unsafe fn init(&mut self) {}
+
+    #[inline]
+    pub unsafe fn lock(&self) {
+        assert_eq!(self.locked.replace(true), false, "cannot recursively acquire mutex");
+    }
+
+    #[inline]
+    pub unsafe fn unlock(&self) {
+        self.locked.set(false);
+    }
+
+    #[inline]
+    pub unsafe fn try_lock(&self) -> bool {
+        self.locked.replace(true) == false
+    }
+
+    #[inline]
+    pub unsafe fn destroy(&self) {}
+}
+
+// All empty stubs because this platform does not yet support threads, so lock
+// acquisition always succeeds.
+pub struct ReentrantMutex {}
+
+impl ReentrantMutex {
+    pub const unsafe fn uninitialized() -> ReentrantMutex {
+        ReentrantMutex {}
+    }
+
+    pub unsafe fn init(&self) {}
+
+    pub unsafe fn lock(&self) {}
+
+    #[inline]
+    pub unsafe fn try_lock(&self) -> bool {
+        true
+    }
+
+    pub unsafe fn unlock(&self) {}
+
+    pub unsafe fn destroy(&self) {}
+}
diff --git a/library/std/src/sys/norostb/net.rs b/library/std/src/sys/norostb/net.rs
new file mode 100644
index 00000000000..879928aca32
--- /dev/null
+++ b/library/std/src/sys/norostb/net.rs
@@ -0,0 +1,413 @@
+use super::cvt_err;
+use crate::cell::Cell;
+use crate::convert::TryFrom;
+use crate::io::{self, IoSlice, IoSliceMut, Write};
+use crate::net::{Ipv4Addr, Ipv6Addr, Shutdown, SocketAddr};
+use crate::sys::unsupported;
+use crate::time::Duration;
+use norostb_rt as rt;
+
+#[derive(Debug)]
+pub struct TcpStream {
+    inner: rt::Object,
+    read_timeout: Cell<Option<Duration>>,
+    write_timeout: Cell<Option<Duration>>,
+}
+
+macro netpath($fmt:literal, $addr:ident) {{
+    let addr = $addr?;
+    let ip = match addr {
+        SocketAddr::V4(a) => a.ip().to_ipv6_mapped(),
+        SocketAddr::V6(a) => *a.ip(),
+    };
+    // 128 bytes ought to be plenty.
+    let mut path = [0; 128];
+    let mut p = &mut path[..];
+    write!(p, $fmt, ip, addr.port()).unwrap();
+    let l = p.len();
+    (path.len() - l, path)
+}}
+
+impl TcpStream {
+    pub fn connect(address: io::Result<&SocketAddr>) -> io::Result<TcpStream> {
+        let (l, p) = netpath!("default/tcp/connect/{}/{}", address);
+        Ok(Self {
+            inner: rt::io::net_root().ok_or(super::ERR_UNSET)?.create(&p[..l]).map_err(cvt_err)?,
+            read_timeout: Cell::new(None),
+            write_timeout: Cell::new(None),
+        })
+    }
+
+    pub fn connect_timeout(_address: &SocketAddr, _timeout: Duration) -> io::Result<TcpStream> {
+        unsupported()
+    }
+
+    pub fn set_read_timeout(&self, timeout: Option<Duration>) -> io::Result<()> {
+        self.read_timeout.set(timeout);
+        Ok(())
+    }
+
+    pub fn set_write_timeout(&self, timeout: Option<Duration>) -> io::Result<()> {
+        self.write_timeout.set(timeout);
+        Ok(())
+    }
+
+    pub fn read_timeout(&self) -> io::Result<Option<Duration>> {
+        Ok(self.read_timeout.get())
+    }
+
+    pub fn write_timeout(&self) -> io::Result<Option<Duration>> {
+        Ok(self.write_timeout.get())
+    }
+
+    pub fn peek(&self, data: &mut [u8]) -> io::Result<usize> {
+        self.inner.peek(data).map_err(cvt_err)
+    }
+
+    pub fn read(&self, data: &mut [u8]) -> io::Result<usize> {
+        self.inner.read(data).map_err(cvt_err)
+    }
+
+    pub fn read_vectored(&self, _data: &mut [IoSliceMut<'_>]) -> io::Result<usize> {
+        unsupported()
+    }
+
+    pub fn is_read_vectored(&self) -> bool {
+        false
+    }
+
+    pub fn write(&self, data: &[u8]) -> io::Result<usize> {
+        self.inner.write(data).map_err(cvt_err)
+    }
+
+    pub fn write_vectored(&self, _data: &[IoSlice<'_>]) -> io::Result<usize> {
+        unsupported()
+    }
+
+    pub fn is_write_vectored(&self) -> bool {
+        false
+    }
+
+    pub fn peer_addr(&self) -> io::Result<SocketAddr> {
+        unsupported()
+    }
+
+    pub fn socket_addr(&self) -> io::Result<SocketAddr> {
+        unsupported()
+    }
+
+    pub fn shutdown(&self, _: Shutdown) -> io::Result<()> {
+        unsupported()
+    }
+
+    pub fn duplicate(&self) -> io::Result<TcpStream> {
+        self.inner
+            .duplicate()
+            .map(|inner| Self {
+                inner,
+                read_timeout: self.read_timeout.clone(),
+                write_timeout: self.write_timeout.clone(),
+            })
+            .map_err(cvt_err)
+    }
+
+    pub fn set_linger(&self, _: Option<Duration>) -> io::Result<()> {
+        unsupported()
+    }
+
+    pub fn linger(&self) -> io::Result<Option<Duration>> {
+        unsupported()
+    }
+
+    pub fn set_nodelay(&self, _: bool) -> io::Result<()> {
+        unsupported()
+    }
+
+    pub fn nodelay(&self) -> io::Result<bool> {
+        unsupported()
+    }
+
+    pub fn set_ttl(&self, _: u32) -> io::Result<()> {
+        unsupported()
+    }
+
+    pub fn ttl(&self) -> io::Result<u32> {
+        unsupported()
+    }
+
+    pub fn take_error(&self) -> io::Result<Option<io::Error>> {
+        unsupported()
+    }
+
+    pub fn set_nonblocking(&self, _: bool) -> io::Result<()> {
+        unsupported()
+    }
+}
+
+#[derive(Debug)]
+pub struct TcpListener {
+    inner: rt::Object,
+}
+
+impl TcpListener {
+    pub fn bind(address: io::Result<&SocketAddr>) -> io::Result<TcpListener> {
+        let (l, p) = netpath!("{}/tcp/listen/{}", address);
+        Ok(Self {
+            inner: rt::io::net_root().ok_or(super::ERR_UNSET)?.create(&p[..l]).map_err(cvt_err)?,
+        })
+    }
+
+    pub fn socket_addr(&self) -> io::Result<SocketAddr> {
+        unsupported()
+    }
+
+    pub fn accept(&self) -> io::Result<(TcpStream, SocketAddr)> {
+        self.inner.open(b"accept").map_err(cvt_err).and_then(|inner| {
+            let peer =
+                TcpStream { inner, read_timeout: Cell::new(None), write_timeout: Cell::new(None) };
+            // FIXME
+            Ok((peer, "0.0.0.0:0".parse().unwrap()))
+            //peer.socket_addr().map(|addr| (peer, addr))
+        })
+    }
+
+    pub fn duplicate(&self) -> io::Result<TcpListener> {
+        unsupported()
+    }
+
+    pub fn set_ttl(&self, _: u32) -> io::Result<()> {
+        unsupported()
+    }
+
+    pub fn ttl(&self) -> io::Result<u32> {
+        unsupported()
+    }
+
+    // The corresponding function still exists in std::net::TcpStream but is deprecated and
+    // hidden from the docs, so we don't need to support it ever.
+    pub fn set_only_v6(&self, _: bool) -> io::Result<()> {
+        unsupported()
+    }
+
+    // Ditto
+    pub fn only_v6(&self) -> io::Result<bool> {
+        unsupported()
+    }
+
+    pub fn take_error(&self) -> io::Result<Option<io::Error>> {
+        unsupported()
+    }
+
+    pub fn set_nonblocking(&self, _: bool) -> io::Result<()> {
+        unsupported()
+    }
+}
+
+#[derive(Debug)]
+pub struct UdpSocket {
+    inner: super::fs::File,
+    read_timeout: Cell<Option<Duration>>,
+    write_timeout: Cell<Option<Duration>>,
+}
+
+impl UdpSocket {
+    pub fn bind(_: io::Result<&SocketAddr>) -> io::Result<UdpSocket> {
+        unsupported()
+    }
+
+    pub fn peer_addr(&self) -> io::Result<SocketAddr> {
+        unsupported()
+    }
+
+    pub fn socket_addr(&self) -> io::Result<SocketAddr> {
+        unsupported()
+    }
+
+    pub fn recv_from(&self, _: &mut [u8]) -> io::Result<(usize, SocketAddr)> {
+        unsupported()
+    }
+
+    pub fn peek_from(&self, _: &mut [u8]) -> io::Result<(usize, SocketAddr)> {
+        unsupported()
+    }
+
+    pub fn send_to(&self, _: &[u8], _: &SocketAddr) -> io::Result<usize> {
+        unsupported()
+    }
+
+    pub fn duplicate(&self) -> io::Result<UdpSocket> {
+        self.inner.duplicate().map(|inner| Self {
+            inner,
+            read_timeout: self.read_timeout.clone(),
+            write_timeout: self.write_timeout.clone(),
+        })
+    }
+
+    pub fn set_read_timeout(&self, timeout: Option<Duration>) -> io::Result<()> {
+        self.read_timeout.set(timeout);
+        Ok(())
+    }
+
+    pub fn set_write_timeout(&self, timeout: Option<Duration>) -> io::Result<()> {
+        self.write_timeout.set(timeout);
+        Ok(())
+    }
+
+    pub fn read_timeout(&self) -> io::Result<Option<Duration>> {
+        Ok(self.read_timeout.get())
+    }
+
+    pub fn write_timeout(&self) -> io::Result<Option<Duration>> {
+        Ok(self.write_timeout.get())
+    }
+
+    pub fn set_broadcast(&self, _: bool) -> io::Result<()> {
+        unsupported()
+    }
+
+    pub fn broadcast(&self) -> io::Result<bool> {
+        unsupported()
+    }
+
+    pub fn set_multicast_loop_v4(&self, _: bool) -> io::Result<()> {
+        unsupported()
+    }
+
+    pub fn multicast_loop_v4(&self) -> io::Result<bool> {
+        unsupported()
+    }
+
+    pub fn set_multicast_ttl_v4(&self, _: u32) -> io::Result<()> {
+        unsupported()
+    }
+
+    pub fn multicast_ttl_v4(&self) -> io::Result<u32> {
+        unsupported()
+    }
+
+    pub fn set_multicast_loop_v6(&self, _: bool) -> io::Result<()> {
+        unsupported()
+    }
+
+    pub fn multicast_loop_v6(&self) -> io::Result<bool> {
+        unsupported()
+    }
+
+    pub fn join_multicast_v4(&self, _: &Ipv4Addr, _: &Ipv4Addr) -> io::Result<()> {
+        unsupported()
+    }
+
+    pub fn join_multicast_v6(&self, _: &Ipv6Addr, _: u32) -> io::Result<()> {
+        unsupported()
+    }
+
+    pub fn leave_multicast_v4(&self, _: &Ipv4Addr, _: &Ipv4Addr) -> io::Result<()> {
+        unsupported()
+    }
+
+    pub fn leave_multicast_v6(&self, _: &Ipv6Addr, _: u32) -> io::Result<()> {
+        unsupported()
+    }
+
+    pub fn set_ttl(&self, _: u32) -> io::Result<()> {
+        unsupported()
+    }
+
+    pub fn ttl(&self) -> io::Result<u32> {
+        unsupported()
+    }
+
+    pub fn take_error(&self) -> io::Result<Option<io::Error>> {
+        unsupported()
+    }
+
+    pub fn set_nonblocking(&self, _: bool) -> io::Result<()> {
+        unsupported()
+    }
+
+    pub fn recv(&self, _: &mut [u8]) -> io::Result<usize> {
+        unsupported()
+    }
+
+    pub fn peek(&self, _: &mut [u8]) -> io::Result<usize> {
+        unsupported()
+    }
+
+    pub fn send(&self, _: &[u8]) -> io::Result<usize> {
+        unsupported()
+    }
+
+    pub fn connect(&self, _: io::Result<&SocketAddr>) -> io::Result<()> {
+        unsupported()
+    }
+}
+
+pub struct LookupHost(!);
+
+impl LookupHost {
+    pub fn port(&self) -> u16 {
+        self.0
+    }
+}
+
+impl Iterator for LookupHost {
+    type Item = SocketAddr;
+    fn next(&mut self) -> Option<SocketAddr> {
+        self.0
+    }
+}
+
+impl TryFrom<&str> for LookupHost {
+    type Error = io::Error;
+
+    fn try_from(_v: &str) -> io::Result<LookupHost> {
+        unsupported()
+    }
+}
+
+impl<'a> TryFrom<(&'a str, u16)> for LookupHost {
+    type Error = io::Error;
+
+    fn try_from(_v: (&'a str, u16)) -> io::Result<LookupHost> {
+        unsupported()
+    }
+}
+
+/// Used by [`std::net::addr`].
+#[allow(nonstandard_style)]
+pub mod netc {
+    pub const AF_INET: u8 = 0;
+    pub const AF_INET6: u8 = 1;
+    pub type sa_family_t = u8;
+
+    #[derive(Copy, Clone)]
+    pub struct in_addr {
+        pub s_addr: u32,
+    }
+
+    #[derive(Copy, Clone)]
+    pub struct sockaddr_in {
+        pub sin_family: sa_family_t,
+        pub sin_port: u16,
+        pub sin_addr: in_addr,
+    }
+
+    #[derive(Copy, Clone)]
+    pub struct in6_addr {
+        pub s6_addr: [u8; 16],
+    }
+
+    #[derive(Copy, Clone)]
+    pub struct sockaddr_in6 {
+        pub sin6_family: sa_family_t,
+        pub sin6_port: u16,
+        pub sin6_addr: in6_addr,
+        pub sin6_flowinfo: u32,
+        pub sin6_scope_id: u32,
+    }
+
+    #[derive(Copy, Clone)]
+    pub struct sockaddr {}
+
+    pub type socklen_t = usize;
+}
diff --git a/library/std/src/sys/norostb/os.rs b/library/std/src/sys/norostb/os.rs
new file mode 100644
index 00000000000..230ac6d0a77
--- /dev/null
+++ b/library/std/src/sys/norostb/os.rs
@@ -0,0 +1,82 @@
+use super::unsupported;
+use crate::error::Error as StdError;
+use crate::ffi::{OsStr, OsString};
+use crate::fmt;
+use crate::io;
+use crate::marker::PhantomData;
+use crate::path::{self, PathBuf};
+
+pub use super::args::{env, getenv, setenv, unsetenv, Env};
+
+pub fn errno() -> i32 {
+    0
+}
+
+pub fn error_string(_errno: i32) -> String {
+    "operation successful".to_string()
+}
+
+pub fn getcwd() -> io::Result<PathBuf> {
+    unsupported()
+}
+
+pub fn chdir(_: &path::Path) -> io::Result<()> {
+    unsupported()
+}
+
+pub struct SplitPaths<'a>(!, PhantomData<&'a ()>);
+
+pub fn split_paths(_unparsed: &OsStr) -> SplitPaths<'_> {
+    panic!("unsupported")
+}
+
+impl<'a> Iterator for SplitPaths<'a> {
+    type Item = PathBuf;
+    fn next(&mut self) -> Option<PathBuf> {
+        self.0
+    }
+}
+
+#[derive(Debug)]
+pub struct JoinPathsError;
+
+pub fn join_paths<I, T>(_paths: I) -> Result<OsString, JoinPathsError>
+where
+    I: Iterator<Item = T>,
+    T: AsRef<OsStr>,
+{
+    Err(JoinPathsError)
+}
+
+impl fmt::Display for JoinPathsError {
+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
+        "not supported on this platform yet".fmt(f)
+    }
+}
+
+impl StdError for JoinPathsError {
+    #[allow(deprecated)]
+    fn description(&self) -> &str {
+        "not supported on this platform yet"
+    }
+}
+
+pub fn current_exe() -> io::Result<PathBuf> {
+    unsupported()
+}
+
+pub fn temp_dir() -> PathBuf {
+    panic!("no filesystem on this platform")
+}
+
+pub fn home_dir() -> Option<PathBuf> {
+    None
+}
+
+pub fn exit(code: i32) -> ! {
+    norostb_rt::exit(code)
+}
+
+pub fn getpid() -> u32 {
+    panic!("no pids on this platform")
+}
diff --git a/library/std/src/sys/norostb/pipe.rs b/library/std/src/sys/norostb/pipe.rs
new file mode 100644
index 00000000000..25514c2322f
--- /dev/null
+++ b/library/std/src/sys/norostb/pipe.rs
@@ -0,0 +1,37 @@
+use crate::io::{self, IoSlice, IoSliceMut};
+
+pub struct AnonPipe(!);
+
+impl AnonPipe {
+    pub fn read(&self, _buf: &mut [u8]) -> io::Result<usize> {
+        self.0
+    }
+
+    pub fn read_vectored(&self, _bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {
+        self.0
+    }
+
+    pub fn is_read_vectored(&self) -> bool {
+        self.0
+    }
+
+    pub fn write(&self, _buf: &[u8]) -> io::Result<usize> {
+        self.0
+    }
+
+    pub fn write_vectored(&self, _bufs: &[IoSlice<'_>]) -> io::Result<usize> {
+        self.0
+    }
+
+    pub fn is_write_vectored(&self) -> bool {
+        self.0
+    }
+
+    pub fn diverge(&self) -> ! {
+        self.0
+    }
+}
+
+pub fn read2(p1: AnonPipe, _v1: &mut Vec<u8>, _p2: AnonPipe, _v2: &mut Vec<u8>) -> io::Result<()> {
+    match p1.0 {}
+}
diff --git a/library/std/src/sys/norostb/process.rs b/library/std/src/sys/norostb/process.rs
new file mode 100644
index 00000000000..1af6994d09c
--- /dev/null
+++ b/library/std/src/sys/norostb/process.rs
@@ -0,0 +1,244 @@
+use crate::ffi::{OsStr, OsString};
+use crate::fmt;
+use crate::io;
+use crate::num::NonZeroI32;
+use crate::os::norostb::prelude::*;
+use crate::path::Path;
+use crate::slice::Iter;
+use crate::sys::fs::File;
+use crate::sys::pipe::AnonPipe;
+use crate::sys::unsupported;
+use crate::sys_common::process::{CommandEnv, CommandEnvs};
+use norostb_rt as rt;
+
+pub use crate::ffi::OsString as EnvKey;
+
+////////////////////////////////////////////////////////////////////////////////
+// Command
+////////////////////////////////////////////////////////////////////////////////
+
+pub struct Command {
+    program: OsString,
+    env: CommandEnv,
+    dir: OsString,
+    args: Vec<OsString>,
+}
+
+// passed back to std::process with the pipes connected to the child, if any
+// were requested
+pub struct StdioPipes {
+    pub stdin: Option<AnonPipe>,
+    pub stdout: Option<AnonPipe>,
+    pub stderr: Option<AnonPipe>,
+}
+
+pub enum Stdio {
+    Inherit,
+    Null,
+    MakePipe,
+}
+
+impl Command {
+    pub fn new(program: &OsStr) -> Self {
+        Self {
+            program: program.into(),
+            env: Default::default(),
+            dir: Default::default(),
+            args: Default::default(),
+        }
+    }
+
+    pub fn arg(&mut self, arg: &OsStr) {
+        self.args.push(arg.into());
+    }
+
+    pub fn env_mut(&mut self) -> &mut CommandEnv {
+        &mut self.env
+    }
+
+    pub fn cwd(&mut self, dir: &OsStr) {
+        self.dir = dir.into();
+    }
+
+    pub fn stdin(&mut self, _stdin: Stdio) {
+        todo!()
+    }
+
+    pub fn stdout(&mut self, _stdout: Stdio) {
+        todo!()
+    }
+
+    pub fn stderr(&mut self, _stderr: Stdio) {
+        todo!()
+    }
+
+    pub fn get_program(&self) -> &OsStr {
+        panic!("unsupported")
+    }
+
+    pub fn get_args(&self) -> CommandArgs<'_> {
+        CommandArgs(self.args.iter())
+    }
+
+    pub fn get_envs(&self) -> CommandEnvs<'_> {
+        self.env.iter()
+    }
+
+    pub fn get_current_dir(&self) -> Option<&Path> {
+        None
+    }
+
+    pub fn spawn(
+        &mut self,
+        _default: Stdio,
+        _needs_stdin: bool,
+    ) -> io::Result<(Process, StdioPipes)> {
+        rt::Process::new(
+            &*rt::io::process_root().ok_or(super::ERR_UNSET)?,
+            &rt::io::file_root()
+                .ok_or(super::ERR_UNSET)?
+                .open(self.program.as_bytes())
+                .map_err(super::cvt_err)?,
+            rt::process::Process::default_handles(),
+            self.args.iter().map(|s| s.as_bytes()),
+            self.env.capture().iter().map(|(k, v)| (k.as_bytes(), v.as_bytes())),
+        )
+        .map_err(super::cvt_err)
+        .map(|p| (Process(p), StdioPipes { stdin: None, stdout: None, stderr: None }))
+    }
+}
+
+impl From<AnonPipe> for Stdio {
+    fn from(pipe: AnonPipe) -> Stdio {
+        pipe.diverge()
+    }
+}
+
+impl From<File> for Stdio {
+    fn from(_file: File) -> Stdio {
+        panic!("unsupported")
+    }
+}
+
+impl fmt::Debug for Command {
+    fn fmt(&self, _f: &mut fmt::Formatter<'_>) -> fmt::Result {
+        Ok(())
+    }
+}
+
+pub struct ExitStatus(!);
+
+impl ExitStatus {
+    pub fn exit_ok(&self) -> Result<(), ExitStatusError> {
+        self.0
+    }
+
+    pub fn code(&self) -> Option<i32> {
+        self.0
+    }
+}
+
+impl Clone for ExitStatus {
+    fn clone(&self) -> ExitStatus {
+        self.0
+    }
+}
+
+impl Copy for ExitStatus {}
+
+impl PartialEq for ExitStatus {
+    fn eq(&self, _other: &ExitStatus) -> bool {
+        self.0
+    }
+}
+
+impl Eq for ExitStatus {}
+
+impl fmt::Debug for ExitStatus {
+    fn fmt(&self, _f: &mut fmt::Formatter<'_>) -> fmt::Result {
+        self.0
+    }
+}
+
+impl fmt::Display for ExitStatus {
+    fn fmt(&self, _f: &mut fmt::Formatter<'_>) -> fmt::Result {
+        self.0
+    }
+}
+
+#[derive(PartialEq, Eq, Clone, Copy, Debug)]
+pub struct ExitStatusError(ExitStatus);
+
+impl Into<ExitStatus> for ExitStatusError {
+    fn into(self) -> ExitStatus {
+        self.0.0
+    }
+}
+
+impl ExitStatusError {
+    pub fn code(self) -> Option<NonZeroI32> {
+        self.0.0
+    }
+}
+
+#[derive(PartialEq, Eq, Clone, Copy, Debug)]
+pub struct ExitCode(bool);
+
+impl ExitCode {
+    pub const SUCCESS: ExitCode = ExitCode(false);
+    pub const FAILURE: ExitCode = ExitCode(true);
+
+    pub fn as_i32(&self) -> i32 {
+        self.0 as i32
+    }
+}
+
+impl From<u8> for ExitCode {
+    fn from(code: u8) -> Self {
+        match code {
+            0 => Self::SUCCESS,
+            1..=255 => Self::FAILURE,
+        }
+    }
+}
+
+pub struct Process(rt::Process);
+
+impl Process {
+    pub fn id(&self) -> u32 {
+        self.0.as_object().as_raw()
+    }
+
+    pub fn kill(&mut self) -> io::Result<()> {
+        unsupported()
+    }
+
+    pub fn wait(&mut self) -> io::Result<ExitStatus> {
+        unsupported()
+    }
+
+    pub fn try_wait(&mut self) -> io::Result<Option<ExitStatus>> {
+        unsupported()
+    }
+}
+
+pub struct CommandArgs<'a>(Iter<'a, OsString>);
+
+impl<'a> Iterator for CommandArgs<'a> {
+    type Item = &'a OsStr;
+    fn next(&mut self) -> Option<&'a OsStr> {
+        self.0.next().map(|s| &**s)
+    }
+
+    fn size_hint(&self) -> (usize, Option<usize>) {
+        self.0.size_hint()
+    }
+}
+
+impl<'a> ExactSizeIterator for CommandArgs<'a> {}
+
+impl<'a> fmt::Debug for CommandArgs<'a> {
+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
+        f.debug_list().finish()
+    }
+}
diff --git a/library/std/src/sys/norostb/rwlock.rs b/library/std/src/sys/norostb/rwlock.rs
new file mode 100644
index 00000000000..8438adeb5b5
--- /dev/null
+++ b/library/std/src/sys/norostb/rwlock.rs
@@ -0,0 +1,68 @@
+use crate::cell::Cell;
+
+pub struct RWLock {
+    // This platform has no threads, so we can use a Cell here.
+    mode: Cell<isize>,
+}
+
+pub type MovableRWLock = RWLock;
+
+unsafe impl Send for RWLock {}
+unsafe impl Sync for RWLock {} // no threads on this platform
+
+impl RWLock {
+    pub const fn new() -> RWLock {
+        RWLock { mode: Cell::new(0) }
+    }
+
+    #[inline]
+    pub unsafe fn read(&self) {
+        let m = self.mode.get();
+        if m >= 0 {
+            self.mode.set(m + 1);
+        } else {
+            rtabort!("rwlock locked for writing");
+        }
+    }
+
+    #[inline]
+    pub unsafe fn try_read(&self) -> bool {
+        let m = self.mode.get();
+        if m >= 0 {
+            self.mode.set(m + 1);
+            true
+        } else {
+            false
+        }
+    }
+
+    #[inline]
+    pub unsafe fn write(&self) {
+        if self.mode.replace(-1) != 0 {
+            rtabort!("rwlock locked for reading")
+        }
+    }
+
+    #[inline]
+    pub unsafe fn try_write(&self) -> bool {
+        if self.mode.get() == 0 {
+            self.mode.set(-1);
+            true
+        } else {
+            false
+        }
+    }
+
+    #[inline]
+    pub unsafe fn read_unlock(&self) {
+        self.mode.set(self.mode.get() - 1);
+    }
+
+    #[inline]
+    pub unsafe fn write_unlock(&self) {
+        assert_eq!(self.mode.replace(0), -1);
+    }
+
+    #[inline]
+    pub unsafe fn destroy(&self) {}
+}
diff --git a/library/std/src/sys/norostb/stdio.rs b/library/std/src/sys/norostb/stdio.rs
new file mode 100644
index 00000000000..855ddc4330e
--- /dev/null
+++ b/library/std/src/sys/norostb/stdio.rs
@@ -0,0 +1,65 @@
+use crate::io;
+use norostb_rt as rt;
+
+pub struct Stdin;
+pub struct Stdout;
+pub struct Stderr;
+
+pub const STDIN_BUF_SIZE: usize = 512;
+
+impl Stdin {
+    pub const fn new() -> Stdin {
+        Stdin
+    }
+}
+
+impl io::Read for Stdin {
+    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {
+        rt::io::stdin().ok_or(super::ERR_UNSET)?.read(buf).map_err(super::cvt_err)
+    }
+}
+
+impl Stdout {
+    pub const fn new() -> Stdout {
+        Stdout
+    }
+}
+
+impl io::Write for Stdout {
+    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {
+        rt::io::stdout().ok_or(super::ERR_UNSET)?.write(buf).map_err(super::cvt_err)
+    }
+
+    fn flush(&mut self) -> io::Result<()> {
+        Ok(())
+    }
+}
+
+impl Stderr {
+    pub const fn new() -> Stderr {
+        Stderr
+    }
+}
+
+impl io::Write for Stderr {
+    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {
+        rt::io::stderr().ok_or(super::ERR_UNSET)?.write(buf).map_err(super::cvt_err)
+    }
+
+    fn flush(&mut self) -> io::Result<()> {
+        Ok(())
+    }
+}
+
+pub fn is_ebadf(_err: &io::Error) -> bool {
+    true
+}
+
+pub fn panic_output() -> Option<impl io::Write> {
+    rt::io::stderr().map(|_| Stderr)
+}
+
+/// # Safety
+///
+/// Must be called only once during runtime initialization.
+pub(super) unsafe fn init() {}
diff --git a/library/std/src/sys/norostb/thread.rs b/library/std/src/sys/norostb/thread.rs
new file mode 100644
index 00000000000..e439f997705
--- /dev/null
+++ b/library/std/src/sys/norostb/thread.rs
@@ -0,0 +1,47 @@
+use super::unsupported;
+use crate::ffi::CStr;
+use crate::io;
+use crate::num::NonZeroUsize;
+use crate::time::Duration;
+use norostb_rt as rt;
+
+pub struct Thread(rt::thread::Thread);
+
+pub const DEFAULT_MIN_STACK_SIZE: usize = 4096;
+
+impl Thread {
+    // unsafe: see thread::Builder::spawn_unchecked for safety requirements
+    pub unsafe fn new(stack: usize, p: Box<dyn FnOnce()>) -> io::Result<Self> {
+        unsafe { rt::thread::Thread::new(stack, p).map_err(super::cvt_err).map(Self) }
+    }
+
+    pub fn yield_now() {
+        rt::thread::sleep(Duration::ZERO);
+    }
+
+    pub fn set_name(_name: &CStr) {
+        // nope
+    }
+
+    pub fn sleep(dur: Duration) {
+        rt::thread::sleep(dur);
+    }
+
+    pub fn join(self) {
+        self.0.wait()
+    }
+}
+
+pub fn available_parallelism() -> io::Result<NonZeroUsize> {
+    unsupported()
+}
+
+pub mod guard {
+    pub type Guard = !;
+    pub unsafe fn current() -> Option<Guard> {
+        None
+    }
+    pub unsafe fn init() -> Option<Guard> {
+        None
+    }
+}
diff --git a/library/std/src/sys/norostb/thread_local_dtor.rs b/library/std/src/sys/norostb/thread_local_dtor.rs
new file mode 100644
index 00000000000..85d66098302
--- /dev/null
+++ b/library/std/src/sys/norostb/thread_local_dtor.rs
@@ -0,0 +1,9 @@
+#![unstable(feature = "thread_local_internals", issue = "none")]
+
+pub unsafe fn register_dtor(_t: *mut u8, _dtor: unsafe extern "C" fn(*mut u8)) {
+    // FIXME: right now there is no concept of "thread exit", but this is likely
+    // going to show up at some point in the form of an exported symbol that the
+    // wasm runtime is going to be expected to call. For now we basically just
+    // ignore the arguments, but if such a function starts to exist it will
+    // likely look like the OSX implementation in `unix/fast_thread_local.rs`
+}
diff --git a/library/std/src/sys/norostb/thread_local_key.rs b/library/std/src/sys/norostb/thread_local_key.rs
new file mode 100644
index 00000000000..720c7fe1995
--- /dev/null
+++ b/library/std/src/sys/norostb/thread_local_key.rs
@@ -0,0 +1,34 @@
+// TODO move part of this to the runtime crate as other languages will need
+// to share the same implementation.
+
+use norostb_rt::tls;
+
+pub type Key = usize;
+
+#[inline]
+pub unsafe fn create(dtor: Option<unsafe extern "C" fn(*mut u8)>) -> Key {
+    let dtor = unsafe { core::mem::transmute(dtor) };
+    tls::allocate(dtor).expect("failed to allocate TLS slot").0
+}
+
+#[inline]
+pub unsafe fn set(key: Key, value: *mut u8) {
+    unsafe {
+        tls::set(tls::Key(key), value.cast());
+    }
+}
+
+#[inline]
+pub unsafe fn get(key: Key) -> *mut u8 {
+    unsafe { tls::get(tls::Key(key)).cast() }
+}
+
+#[inline]
+pub unsafe fn destroy(key: Key) {
+    unsafe { tls::free(tls::Key(key)) }
+}
+
+#[inline]
+pub fn requires_synchronized_create() -> bool {
+    false
+}
diff --git a/library/std/src/sys/norostb/time.rs b/library/std/src/sys/norostb/time.rs
new file mode 100644
index 00000000000..6d67b538a96
--- /dev/null
+++ b/library/std/src/sys/norostb/time.rs
@@ -0,0 +1,45 @@
+use crate::time::Duration;
+
+#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Debug, Hash)]
+pub struct Instant(Duration);
+
+#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Debug, Hash)]
+pub struct SystemTime(Duration);
+
+pub const UNIX_EPOCH: SystemTime = SystemTime(Duration::from_secs(0));
+
+impl Instant {
+    pub fn now() -> Instant {
+        panic!("time not implemented on this platform")
+    }
+
+    pub fn checked_sub_instant(&self, other: &Instant) -> Option<Duration> {
+        self.0.checked_sub(other.0)
+    }
+
+    pub fn checked_add_duration(&self, other: &Duration) -> Option<Instant> {
+        Some(Instant(self.0.checked_add(*other)?))
+    }
+
+    pub fn checked_sub_duration(&self, other: &Duration) -> Option<Instant> {
+        Some(Instant(self.0.checked_sub(*other)?))
+    }
+}
+
+impl SystemTime {
+    pub fn now() -> SystemTime {
+        panic!("time not implemented on this platform")
+    }
+
+    pub fn sub_time(&self, other: &SystemTime) -> Result<Duration, Duration> {
+        self.0.checked_sub(other.0).ok_or_else(|| other.0 - self.0)
+    }
+
+    pub fn checked_add_duration(&self, other: &Duration) -> Option<SystemTime> {
+        Some(SystemTime(self.0.checked_add(*other)?))
+    }
+
+    pub fn checked_sub_duration(&self, other: &Duration) -> Option<SystemTime> {
+        Some(SystemTime(self.0.checked_sub(*other)?))
+    }
+}
diff --git a/library/std/src/sys_common/mod.rs b/library/std/src/sys_common/mod.rs
index 804727fbc54..b7fde6e5a4c 100644
--- a/library/std/src/sys_common/mod.rs
+++ b/library/std/src/sys_common/mod.rs
@@ -39,6 +39,7 @@
 cfg_if::cfg_if! {
     if #[cfg(any(target_os = "l4re",
                  target_os = "hermit",
+                 target_os = "norostb",
                  feature = "restricted-std",
                  all(target_family = "wasm", not(target_os = "emscripten")),
                  all(target_vendor = "fortanix", target_env = "sgx")))] {
