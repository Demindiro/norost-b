From 459dc917ec6c8cc5131ff77f013c78fa769dadcb Mon Sep 17 00:00:00 2001
From: David Hoppenbrouwers <david@salt-inc.org>
Date: Wed, 27 Apr 2022 22:27:12 +0200
Subject: [PATCH 33/45] Move runtime globals to norostb_rt

This is necessary so interop with other languages will work properly
---
 library/std/src/os/norostb/mod.rs             |   5 -
 library/std/src/sys/norostb/alloc.rs          |  67 ++----
 library/std/src/sys/norostb/args.rs           | 134 ++---------
 library/std/src/sys/norostb/fs.rs             |  47 ++--
 library/std/src/sys/norostb/io.rs             | 222 +-----------------
 library/std/src/sys/norostb/mod.rs            |  14 +-
 library/std/src/sys/norostb/os.rs             |   3 +-
 library/std/src/sys/norostb/process.rs        |   2 +-
 library/std/src/sys/norostb/stdio.rs          |  16 +-
 library/std/src/sys/norostb/thread.rs         | 109 +--------
 .../std/src/sys/norostb/thread_local_key.rs   |  27 +--
 11 files changed, 96 insertions(+), 550 deletions(-)

diff --git a/library/std/src/os/norostb/mod.rs b/library/std/src/os/norostb/mod.rs
index 4c75f2a691c..2cb85e49d2f 100644
--- a/library/std/src/os/norostb/mod.rs
+++ b/library/std/src/os/norostb/mod.rs
@@ -3,11 +3,6 @@
 pub mod ffi;
 pub mod io;
 
-pub use crate::sys::io::{
-    create, finish_job, open, poll, query, query_next, read, seek, take_job, write,
-};
-pub use norostb_rt::kernel::io::{Job, ObjectInfo};
-
 pub mod prelude {
     use super::*;
     pub use ffi::OsStrExt;
diff --git a/library/std/src/sys/norostb/alloc.rs b/library/std/src/sys/norostb/alloc.rs
index 80664e9fd25..da879fb0b9d 100644
--- a/library/std/src/sys/norostb/alloc.rs
+++ b/library/std/src/sys/norostb/alloc.rs
@@ -1,57 +1,20 @@
-use crate::alloc::{Allocator as Alloc, GlobalAlloc, Layout, System};
-use crate::ptr::{self, NonNull};
-use crate::sys_common::mutex::StaticMutex;
-use norostb_rt::alloc::Allocator;
+use crate::alloc::{GlobalAlloc, Layout, System};
 
-static ALLOCATOR_LOCK: StaticMutex = StaticMutex::new();
-static mut ALLOCATOR: Allocator = Allocator::new();
-
-#[stable(feature = "alloc_system_type", since = "1.28.0")]
-unsafe impl GlobalAlloc for System {
-    #[inline]
-    unsafe fn alloc(&self, layout: Layout) -> *mut u8 {
-        unsafe {
-            let _guard = ALLOCATOR_LOCK.lock();
-            ALLOCATOR.allocate(layout).map_or(ptr::null_mut(), |p| p.as_ptr().as_mut_ptr())
-        }
-    }
-
-    #[inline]
-    unsafe fn alloc_zeroed(&self, layout: Layout) -> *mut u8 {
-        unsafe {
-            let _guard = ALLOCATOR_LOCK.lock();
-            ALLOCATOR.allocate_zeroed(layout).map_or(ptr::null_mut(), |p| p.as_ptr().as_mut_ptr())
-        }
-    }
-
-    #[inline]
-    unsafe fn dealloc(&self, ptr: *mut u8, layout: Layout) {
-        debug_assert!(!ptr.is_null());
-        unsafe {
-            let _guard = ALLOCATOR_LOCK.lock();
-            ALLOCATOR.deallocate(NonNull::new_unchecked(ptr), layout)
-        }
-    }
-
-    #[inline]
-    unsafe fn realloc(&self, ptr: *mut u8, layout: Layout, new_size: usize) -> *mut u8 {
-        debug_assert!(!ptr.is_null());
-        let old_layout = layout;
-        if let Ok(new_layout) = Layout::from_size_align(new_size, layout.align()) {
+macro_rules! imp {
+    ($fn:ident($($args:ident : $ty:ty),*) -> $ret:ty) => {
+        #[inline]
+        unsafe fn $fn(&self, $($args:$ty),*) -> $ret {
             unsafe {
-                let _guard = ALLOCATOR_LOCK.lock();
-                if new_layout.size() > old_layout.size() {
-                    ALLOCATOR
-                        .grow(NonNull::new_unchecked(ptr), old_layout, new_layout)
-                        .map_or(ptr::null_mut(), |p| p.as_ptr().as_mut_ptr())
-                } else {
-                    ALLOCATOR
-                        .shrink(NonNull::new_unchecked(ptr), old_layout, new_layout)
-                        .map_or(ptr::null_mut(), |p| p.as_ptr().as_mut_ptr())
-                }
+                norostb_rt::alloc::ALLOCATOR.$fn($($args),*)
             }
-        } else {
-            ptr::null_mut()
         }
-    }
+    };
+}
+
+#[stable(feature = "alloc_system_type", since = "1.28.0")]
+unsafe impl GlobalAlloc for System {
+    imp!(alloc(layout: Layout) -> *mut u8);
+    imp!(alloc_zeroed(layout: Layout) -> *mut u8);
+    imp!(dealloc(ptr: *mut u8, layout: Layout) -> ());
+    imp!(realloc(ptr: *mut u8, layout: Layout, new_size: usize) -> *mut u8);
 }
diff --git a/library/std/src/sys/norostb/args.rs b/library/std/src/sys/norostb/args.rs
index f14cfc6ae08..dc96c9d5fdd 100644
--- a/library/std/src/sys/norostb/args.rs
+++ b/library/std/src/sys/norostb/args.rs
@@ -1,150 +1,66 @@
-use crate::collections::{btree_map, BTreeMap};
 use crate::ffi::{OsStr, OsString};
-use crate::fmt;
 use crate::io;
-use crate::lazy::SyncOnceCell;
-use crate::os::norostb::prelude::*;
-use crate::ptr::{self, NonNull};
-use crate::slice;
-use crate::sync::{
-    atomic::{AtomicPtr, Ordering},
-    Mutex,
-};
+use crate::os::norostb::ffi::{OsStrExt, OsStringExt};
 
-static ARGS_AND_ENV: AtomicPtr<u8> = AtomicPtr::new(ptr::null_mut());
-static ENV: SyncOnceCell<Mutex<BTreeMap<OsString, OsString>>> = SyncOnceCell::new();
+use norostb_rt::args;
 
-pub struct Args {
-    count: usize,
-    ptr: NonNull<u8>,
-}
-
-pub fn args() -> Args {
-    unsafe {
-        let ptr = NonNull::new(ARGS_AND_ENV.load(Ordering::Relaxed))
-            .expect("No arguments were set")
-            .cast::<u16>();
-        Args {
-            count: usize::from(ptr.as_ptr().read_unaligned()),
-            ptr: NonNull::new(ptr.as_ptr().add(1).cast()).unwrap(),
-        }
-    }
-}
-
-impl fmt::Debug for Args {
-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
-        let args = Args { count: self.count, ptr: self.ptr };
-        let mut f = f.debug_list();
-        for e in args {
-            f.entry(&e);
-        }
-        f.finish()
-    }
-}
+#[derive(Debug)]
+pub struct Args(args::Args);
 
 impl Iterator for Args {
     type Item = OsString;
 
-    fn next(&mut self) -> Option<OsString> {
-        self.count.checked_sub(1).map(|c| {
-            self.count = c;
-            unsafe {
-                let (val, ptr) = get_str(self.ptr.as_ptr());
-                self.ptr = NonNull::new(ptr).unwrap();
-                val
-            }
-        })
-    }
-
-    fn size_hint(&self) -> (usize, Option<usize>) {
-        (self.count, Some(self.count))
+    fn next(&mut self) -> Option<Self::Item> {
+        self.0.next().map(OsStr::from_bytes).map(Into::into)
     }
 }
 
 impl ExactSizeIterator for Args {
     fn len(&self) -> usize {
-        self.count
+        self.0.len()
     }
 }
 
 impl DoubleEndedIterator for Args {
-    fn next_back(&mut self) -> Option<OsString> {
-        self.count.checked_sub(1).map(|c| {
-            // Very inefficient but w/e, it shouldn't matter.
-            let args = Args { count: self.count, ptr: self.ptr };
-            self.count = c;
-            args.last().unwrap()
-        })
+    fn next_back(&mut self) -> Option<Self::Item> {
+        self.0.next_back().map(OsStr::from_bytes).map(Into::into)
     }
 }
 
-pub struct Env {
-    inner: btree_map::IntoIter<OsString, OsString>,
-}
+#[derive(Debug)]
+pub struct Env(args::Env);
 
 impl Iterator for Env {
     type Item = (OsString, OsString);
 
-    fn next(&mut self) -> Option<(OsString, OsString)> {
-        self.inner.next()
+    fn next(&mut self) -> Option<Self::Item> {
+        self.0.next().map(|(key, val)| {
+            (OsString::from_vec(key.into_owned()), OsString::from_vec(val.into_owned()))
+        })
     }
 }
 
-fn get_env() -> &'static Mutex<BTreeMap<OsString, OsString>> {
-    ENV.get_or_init(|| {
-        // A finished args iterator will point to the start of the env variables.
-        let mut args = args();
-        (&mut args).last();
-        // Load all env variables in a map so we can easily modify & remove variables.
-        let mut map = BTreeMap::new();
-        unsafe {
-            let ptr = args.ptr.as_ptr().cast::<u16>();
-            let count = usize::from(ptr.read_unaligned());
-            let mut ptr = ptr.add(1).cast::<u8>();
-            for _ in 0..count {
-                let (key, p) = get_str(ptr);
-                let (val, p) = get_str(p);
-                map.insert(key, val);
-                ptr = p;
-            }
-        }
-        Mutex::new(map)
-    })
+pub fn args() -> Args {
+    Args(args::Args::new())
 }
 
 pub fn env() -> Env {
-    // "The returned iterator contains a snapshot of the processâ€™s environment variables ..." &
-    // "Modifications to environment variables afterwards will not be reflected ..."
-    // means we need to clone it, or at least use some kind of CoW.
-    Env { inner: get_env().lock().expect("failed to lock environment map").clone().into_iter() }
+    Env(args::Env::new())
 }
 
 pub fn getenv(key: &OsStr) -> Option<OsString> {
-    get_env().lock().expect("failed to lock environment map").get(key).cloned()
+    args::Env::get(OsStr::as_bytes(key)).map(|val| OsString::from_vec(val.into_owned()))
 }
 
 pub fn setenv(key: &OsStr, value: &OsStr) -> io::Result<()> {
-    get_env().lock().expect("failed to lock environment map").insert(key.into(), value.into());
-    Ok(())
+    let f = |v| Vec::from(OsStr::as_bytes(v)).into();
+    args::Env::try_insert(f(key), f(value))
+        .map(|_| ())
+        .map_err(|_| io::const_io_error!(io::ErrorKind::OutOfMemory, "out of memory"))
 }
 
 pub fn unsetenv(key: &OsStr) -> io::Result<()> {
-    // Removing non-existent env variables is valid apparently...
-    get_env().lock().expect("failed to lock environment map").remove(key);
+    // Removing non-existent env variables is valid in stdlib.
+    let _ = args::Env::remove(OsStr::as_bytes(key));
     Ok(())
 }
-
-/// # Safety
-///
-/// Must be called only once during runtime initialization.
-pub(super) unsafe fn init(args_and_env: *const u8) {
-    ARGS_AND_ENV.store(args_and_env as _, Ordering::Relaxed)
-}
-
-unsafe fn get_str(ptr: *mut u8) -> (OsString, *mut u8) {
-    let len = usize::from(unsafe { ptr.cast::<u16>().read_unaligned() });
-    let ptr = ptr.wrapping_add(2);
-    let mut s = OsString::new();
-    s.push(OsStr::from_bytes(unsafe { slice::from_raw_parts(ptr, len) }));
-    (s, ptr.wrapping_add(len))
-}
diff --git a/library/std/src/sys/norostb/fs.rs b/library/std/src/sys/norostb/fs.rs
index 87def158b98..90da716d010 100644
--- a/library/std/src/sys/norostb/fs.rs
+++ b/library/std/src/sys/norostb/fs.rs
@@ -1,3 +1,4 @@
+use super::cvt_err;
 /// ## Path format
 ///
 /// ```
@@ -22,9 +23,10 @@
 use crate::sys::time::SystemTime;
 use crate::sys::unsupported;
 use crate::sys_common::{AsInner, FromInner};
-use norostb_rt::kernel::{
-    io::{Handle, ObjectInfo},
-    syscall::{self, TableId, TableInfo},
+use norostb_rt::{
+    io as rt_io,
+    table::{ObjectInfo, TableId, TableInfo, TableIter},
+    Handle,
 };
 
 #[derive(Debug)]
@@ -40,10 +42,10 @@ pub enum FileAttr {
     Object { size: u64 },
 }
 
-#[derive(Clone, Debug)]
+#[derive(Debug)]
 pub enum ReadDir {
     None,
-    Tables(Option<TableId>),
+    Tables(TableIter),
     Objects { table_id: TableId, table_info: TableInfo, query: Handle },
 }
 
@@ -139,15 +141,15 @@ impl Iterator for ReadDir {
     fn next(&mut self) -> Option<io::Result<DirEntry>> {
         match mem::replace(self, Self::None) {
             Self::None => None,
-            Self::Tables(tbl) => syscall::next_table(tbl).map(|(id, info)| {
-                *self = Self::Tables(Some(id));
+            Self::Tables(mut tbl) => tbl.next().map(|(id, info)| {
+                *self = Self::Tables(tbl);
                 Ok(DirEntry::Table { id, info })
             }),
             Self::Objects { table_id, table_info, query } => {
                 let mut inner = Vec::with_capacity(4096);
                 inner.resize(4096, 0);
                 let mut info = ObjectInfo::new(&mut inner);
-                match super::io::query_next(query, &mut info) {
+                match rt_io::query_next(query, &mut info) {
                     Ok(true) => {
                         inner.resize(info.path_len, 0);
                         let name = OsString::from_inner(Buf { inner }).into();
@@ -236,11 +238,11 @@ pub fn open(path: &Path, opts: &OpenOptions) -> io::Result<File> {
                 return Err(io::const_io_error!(io::ErrorKind::Other, "expected full path"));
             };
             let table = find_table(table)?.0;
-            super::io::create(table, path).map(|handle| File { handle })
+            rt_io::create(table, path).map(|handle| File { handle }).map_err(cvt_err)
         } else {
             // Find a unique ID
             let (table_id, path) = split_into_table_and_path(path)?;
-            super::io::open(table_id, path).map(|handle| File { handle })
+            rt_io::open(table_id, path).map(|handle| File { handle }).map_err(cvt_err)
         }
     }
 
@@ -263,7 +265,7 @@ pub fn truncate(&self, _size: u64) -> io::Result<()> {
     }
 
     pub fn read(&self, buf: &mut [u8]) -> io::Result<usize> {
-        super::io::read(self.handle, buf)
+        rt_io::read(self.handle, buf).map_err(cvt_err)
     }
 
     pub fn read_vectored(&self, _bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {
@@ -277,7 +279,7 @@ pub fn is_read_vectored(&self) -> bool {
     pub fn read_buf(&self, buf: &mut ReadBuf<'_>) -> io::Result<()> {
         // SAFETY: we don't deinitialize any part of the buffer
         let s = unsafe { buf.unfilled_mut() };
-        let len = super::io::read_uninit(self.handle, s)?;
+        let len = rt_io::read_uninit(self.handle, s).map_err(cvt_err)?;
         // SAFETY: the kernel has initialized `len` bytes.
         unsafe {
             buf.assume_init(buf.filled().len() + len);
@@ -287,7 +289,7 @@ pub fn read_buf(&self, buf: &mut ReadBuf<'_>) -> io::Result<()> {
     }
 
     pub fn write(&self, buf: &[u8]) -> io::Result<usize> {
-        super::io::write(self.handle, buf)
+        rt_io::write(self.handle, buf).map_err(cvt_err)
     }
 
     pub fn write_vectored(&self, _bufs: &[IoSlice<'_>]) -> io::Result<usize> {
@@ -304,13 +306,16 @@ pub fn flush(&self) -> io::Result<()> {
     }
 
     pub fn seek(&self, pos: SeekFrom) -> io::Result<u64> {
-        super::io::seek(self.handle, pos)
+        let pos = match pos {
+            SeekFrom::Start(n) => rt_io::SeekFrom::Start(n),
+            SeekFrom::Current(n) => rt_io::SeekFrom::Current(n),
+            SeekFrom::End(n) => rt_io::SeekFrom::End(n),
+        };
+        rt_io::seek(self.handle, pos).map_err(cvt_err)
     }
 
     pub fn duplicate(&self) -> io::Result<File> {
-        syscall::duplicate_handle(self.handle)
-            .map_err(|_| io::const_io_error!(io::ErrorKind::Uncategorized, "TODO failed duplicate"))
-            .map(|handle| Self { handle })
+        rt_io::duplicate(self.handle).map_err(cvt_err).map(|handle| Self { handle })
     }
 
     pub fn set_permissions(&self, _perm: FilePermissions) -> io::Result<()> {
@@ -320,7 +325,7 @@ pub fn set_permissions(&self, _perm: FilePermissions) -> io::Result<()> {
 
 impl Drop for File {
     fn drop(&mut self) {
-        super::io::close(self.handle);
+        rt_io::close(self.handle);
     }
 }
 
@@ -336,15 +341,15 @@ pub fn mkdir(&self, _p: &Path) -> io::Result<()> {
 
 pub fn readdir(path: &Path) -> io::Result<ReadDir> {
     match split_path(path)? {
-        SplitPath::None => Ok(ReadDir::Tables(None)),
+        SplitPath::None => Ok(ReadDir::Tables(TableIter::new().map_err(cvt_err)?)),
         SplitPath::Table { table } => {
             let (table_id, table_info) = find_table(table)?;
-            let query = super::io::query(table_id, &[])?;
+            let query = rt_io::query(table_id, &[]).map_err(cvt_err)?;
             Ok(ReadDir::Objects { table_id, table_info, query })
         }
         SplitPath::Path { table, path } => {
             let (table_id, table_info) = find_table(table)?;
-            let query = super::io::query(table_id, path)?;
+            let query = rt_io::query(table_id, path).map_err(cvt_err)?;
             Ok(ReadDir::Objects { table_id, table_info, query })
         }
     }
diff --git a/library/std/src/sys/norostb/io.rs b/library/std/src/sys/norostb/io.rs
index 4c9ddf93d7e..d5f475b4310 100644
--- a/library/std/src/sys/norostb/io.rs
+++ b/library/std/src/sys/norostb/io.rs
@@ -1,10 +1,4 @@
-use crate::cell::RefCell;
-use crate::io;
-use crate::mem::{self, MaybeUninit};
-use norostb_rt::kernel::{
-    io::{Job, ObjectInfo, Queue, Request, Response, SeekFrom},
-    syscall::{self, TableId, TableInfo},
-};
+use crate::mem;
 
 #[derive(Copy, Clone)]
 pub struct IoSlice<'a>(&'a [u8]);
@@ -51,217 +45,3 @@ pub fn as_mut_slice(&mut self) -> &mut [u8] {
         self.0
     }
 }
-
-thread_local! {
-    static QUEUE: RefCell<Queue> = RefCell::new({
-        Queue {
-            base: syscall::create_io_queue(None, 0, 0)
-                .unwrap_or_else(|e| rtabort!("failed to create io queue: {:?}", e))
-                .cast(),
-            requests_mask: 0,
-            responses_mask: 0,
-        }
-    });
-}
-
-fn enqueue(request: Request) -> Response {
-    QUEUE.with(|queue| unsafe {
-        let mut queue = queue.borrow_mut();
-        queue.enqueue_request(request).unwrap();
-        syscall::process_io_queue(Some(queue.base.cast())).unwrap();
-        loop {
-            if let Ok(e) = queue.dequeue_response() {
-                break e;
-            }
-            syscall::wait_io_queue(Some(queue.base.cast())).unwrap();
-        }
-    })
-}
-
-/// Blocking read
-#[unstable(feature = "norostb", issue = "none")]
-#[inline]
-pub fn read(handle: syscall::Handle, data: &mut [u8]) -> io::Result<usize> {
-    unsafe { read_uninit(handle, mem::transmute(data)) }
-}
-
-/// Blocking read
-#[unstable(feature = "norostb", issue = "none")]
-#[inline]
-pub fn read_uninit(handle: syscall::Handle, data: &mut [MaybeUninit<u8>]) -> io::Result<usize> {
-    let e = enqueue(Request::read_uninit(0, handle, data));
-    if e.value < 0 {
-        Err(io::const_io_error!(io::ErrorKind::Uncategorized, "failed to read"))
-    } else {
-        Ok(e.value as usize)
-    }
-}
-
-/// Blocking write
-#[unstable(feature = "norostb", issue = "none")]
-#[inline]
-pub fn write(handle: syscall::Handle, data: &[u8]) -> io::Result<usize> {
-    let e = enqueue(Request::write(0, handle, data));
-    if e.value < 0 {
-        Err(io::const_io_error!(io::ErrorKind::Uncategorized, "failed to write"))
-    } else {
-        Ok(e.value as usize)
-    }
-}
-
-/// Blocking open
-#[unstable(feature = "norostb", issue = "none")]
-#[inline]
-pub fn open(table: syscall::TableId, path: &[u8]) -> io::Result<syscall::Handle> {
-    let e = enqueue(Request::open(0, table, path));
-    if e.value < 0 {
-        Err(io::const_io_error!(io::ErrorKind::Uncategorized, "failed to open"))
-    } else {
-        // This error pops up despite stdlib already using 2021 edition?!?
-        /*
-            = help: items from traits can only be used if the trait is in scope
-            = note: 'core::convert::TryInto' is included in the prelude starting in Edition 2021
-        help: the following trait is implemented but not in scope; perhaps add a `use` for it:
-                */
-        use crate::convert::TryInto;
-        Ok(e.value.try_into().unwrap())
-    }
-}
-
-/// Blocking create
-#[unstable(feature = "norostb", issue = "none")]
-#[inline]
-pub fn create(table: syscall::TableId, path: &[u8]) -> io::Result<syscall::Handle> {
-    let e = enqueue(Request::create(0, table, path));
-    if e.value < 0 {
-        Err(io::const_io_error!(io::ErrorKind::Uncategorized, "failed to create"))
-    } else {
-        // This error pops up despite stdlib already using 2021 edition?!?
-        /*
-            = help: items from traits can only be used if the trait is in scope
-            = note: 'core::convert::TryInto' is included in the prelude starting in Edition 2021
-        help: the following trait is implemented but not in scope; perhaps add a `use` for it:
-                */
-        use crate::convert::TryInto;
-        Ok(e.value.try_into().unwrap())
-    }
-}
-
-/// Blocking query
-#[unstable(feature = "norostb", issue = "none")]
-#[inline]
-pub fn query(table: syscall::TableId, path: &[u8]) -> io::Result<syscall::Handle> {
-    let e = enqueue(Request::query(0, table, path));
-    if e.value < 0 {
-        Err(io::const_io_error!(io::ErrorKind::Uncategorized, "failed to query"))
-    } else {
-        // This error pops up despite stdlib already using 2021 edition?!?
-        /*
-            = help: items from traits can only be used if the trait is in scope
-            = note: 'core::convert::TryInto' is included in the prelude starting in Edition 2021
-        help: the following trait is implemented but not in scope; perhaps add a `use` for it:
-                */
-        use crate::convert::TryInto;
-        Ok(e.value.try_into().unwrap())
-    }
-}
-
-/// Blocking query_next
-#[unstable(feature = "norostb", issue = "none")]
-#[inline]
-pub fn query_next(query: syscall::Handle, info: &mut ObjectInfo) -> io::Result<bool> {
-    let e = enqueue(Request::query_next(0, query, info));
-    if e.value < 0 {
-        // FIXME the API for quering is kinda broken right now.
-        //Err(io::const_io_error!(io::ErrorKind::Uncategorized, "failed to advance query"))
-        Ok(false)
-    } else {
-        Ok(e.value > 0)
-    }
-}
-
-/// Blocking take_job
-#[unstable(feature = "norostb", issue = "none")]
-#[inline]
-pub fn take_job(table: syscall::Handle, job: &mut Job) -> io::Result<()> {
-    let e = enqueue(Request::take_job(0, table, job));
-    if e.value < 0 {
-        Err(io::const_io_error!(io::ErrorKind::Uncategorized, "failed to take job"))
-    } else {
-        Ok(())
-    }
-}
-
-/// Blocking finish_job
-#[unstable(feature = "norostb", issue = "none")]
-#[inline]
-pub fn finish_job(table: syscall::Handle, job: &Job) -> io::Result<()> {
-    let e = enqueue(Request::finish_job(0, table, &job));
-    if e.value < 0 {
-        Err(io::const_io_error!(io::ErrorKind::Uncategorized, "failed to finish job"))
-    } else {
-        Ok(())
-    }
-}
-
-/// Blocking seek
-#[unstable(feature = "norostb", issue = "none")]
-#[inline]
-pub fn seek(handle: syscall::Handle, from: io::SeekFrom) -> io::Result<u64> {
-    let from = match from {
-        io::SeekFrom::Start(n) => SeekFrom::Start(n),
-        io::SeekFrom::End(n) => SeekFrom::End(n),
-        io::SeekFrom::Current(n) => SeekFrom::Current(n),
-    };
-    let e = enqueue(Request::seek(0, handle, from));
-    if e.value < 0 {
-        Err(io::const_io_error!(io::ErrorKind::Uncategorized, "failed to seek"))
-    } else {
-        Ok(e.value as u64)
-    }
-}
-
-/// Blocking poll
-#[unstable(feature = "norostb", issue = "none")]
-#[inline]
-pub fn poll(handle: syscall::Handle) -> io::Result<usize> {
-    let e = enqueue(Request::poll(0, handle));
-    if e.value < 0 {
-        Err(io::const_io_error!(io::ErrorKind::Uncategorized, "failed to poll"))
-    } else {
-        Ok(e.value as usize)
-    }
-}
-
-/// Blocking close
-#[unstable(feature = "norostb", issue = "none")]
-#[inline]
-pub fn close(handle: syscall::Handle) {
-    enqueue(Request::close(0, handle));
-}
-
-/// Create an iterator over all tables.
-#[unstable(feature = "norostb", issue = "none")]
-#[inline]
-pub fn tables() -> TableIter {
-    TableIter { state: Some(None) }
-}
-
-/// An iterator over all tables.
-#[derive(Clone, Debug)]
-#[unstable(feature = "norostb", issue = "none")]
-pub struct TableIter {
-    state: Option<Option<TableId>>,
-}
-
-impl Iterator for TableIter {
-    type Item = (TableId, TableInfo);
-
-    #[inline]
-    fn next(&mut self) -> Option<Self::Item> {
-        self.state.take().and_then(|id| syscall::next_table(id)).map(|(id, info)| {
-            self.state = Some(Some(id));
-            (id, info)
-        })
-    }
-}
diff --git a/library/std/src/sys/norostb/mod.rs b/library/std/src/sys/norostb/mod.rs
index a9efd8546af..098eab958e7 100644
--- a/library/std/src/sys/norostb/mod.rs
+++ b/library/std/src/sys/norostb/mod.rs
@@ -44,13 +44,9 @@ pub extern "C" fn __rust_abort() {
 /// # Note
 ///
 /// This is not guaranteed to run, for example when Rust code is called externally.
-// FIXME The current signature is actually wrong, but I'm unsure how to fix it.
-//pub unsafe fn init(_arguments: *const u8) {
-pub unsafe fn init(_argc: isize, _argv: *const *const u8) {
+pub unsafe fn init(_: isize, _: *const *const u8) {
     // FIXME this is not guaranteed to run.
     unsafe {
-        args::init(_argc as *const u8);
-        thread_local_key::init_thread();
         stdio::init();
     }
 }
@@ -63,3 +59,11 @@ pub unsafe fn init(_argc: isize, _argv: *const *const u8) {
 ///
 /// This is not guaranteed to run, for example when Rust code is called externally.
 pub unsafe fn cleanup() {}
+
+fn cvt_err(err: norostb_rt::Error) -> crate::io::Error {
+    use crate::io::{const_io_error, ErrorKind};
+    use norostb_rt::Error;
+    match err {
+        Error::Unknown => const_io_error!(ErrorKind::Uncategorized, "uncategorized error"),
+    }
+}
diff --git a/library/std/src/sys/norostb/os.rs b/library/std/src/sys/norostb/os.rs
index 94cfcc15453..230ac6d0a77 100644
--- a/library/std/src/sys/norostb/os.rs
+++ b/library/std/src/sys/norostb/os.rs
@@ -5,7 +5,6 @@
 use crate::io;
 use crate::marker::PhantomData;
 use crate::path::{self, PathBuf};
-use norostb_rt::kernel::syscall;
 
 pub use super::args::{env, getenv, setenv, unsetenv, Env};
 
@@ -75,7 +74,7 @@ pub fn home_dir() -> Option<PathBuf> {
 }
 
 pub fn exit(code: i32) -> ! {
-    syscall::exit(code)
+    norostb_rt::exit(code)
 }
 
 pub fn getpid() -> u32 {
diff --git a/library/std/src/sys/norostb/process.rs b/library/std/src/sys/norostb/process.rs
index f4874b3d196..344e622ec7a 100644
--- a/library/std/src/sys/norostb/process.rs
+++ b/library/std/src/sys/norostb/process.rs
@@ -8,7 +8,7 @@
 use crate::sys::pipe::AnonPipe;
 use crate::sys::unsupported;
 use crate::sys_common::process::{CommandEnv, CommandEnvs};
-use norostb_rt::kernel::io::Handle;
+use norostb_rt::Handle;
 
 pub use crate::ffi::OsString as EnvKey;
 
diff --git a/library/std/src/sys/norostb/stdio.rs b/library/std/src/sys/norostb/stdio.rs
index 01c8cdc0e6e..7265037b5a2 100644
--- a/library/std/src/sys/norostb/stdio.rs
+++ b/library/std/src/sys/norostb/stdio.rs
@@ -1,5 +1,5 @@
 use crate::{io, sync::atomic::Ordering};
-use norostb_rt::kernel::AtomicHandle;
+use norostb_rt::{self as rt, AtomicHandle};
 
 static STDIN: AtomicHandle = AtomicHandle::new(0);
 static STDOUT: AtomicHandle = AtomicHandle::new(0);
@@ -19,7 +19,7 @@ pub const fn new() -> Stdin {
 
 impl io::Read for Stdin {
     fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {
-        super::io::read(STDIN.load(Ordering::Relaxed), buf)
+        rt::io::read(STDIN.load(Ordering::Relaxed), buf).map_err(super::cvt_err)
     }
 }
 
@@ -31,7 +31,7 @@ pub const fn new() -> Stdout {
 
 impl io::Write for Stdout {
     fn write(&mut self, buf: &[u8]) -> io::Result<usize> {
-        super::io::write(STDOUT.load(Ordering::Relaxed), buf)
+        rt::io::write(STDOUT.load(Ordering::Relaxed), buf).map_err(super::cvt_err)
     }
 
     fn flush(&mut self) -> io::Result<()> {
@@ -47,7 +47,7 @@ pub const fn new() -> Stderr {
 
 impl io::Write for Stderr {
     fn write(&mut self, buf: &[u8]) -> io::Result<usize> {
-        super::io::write(STDERR.load(Ordering::Relaxed), buf)
+        rt::io::write(STDERR.load(Ordering::Relaxed), buf).map_err(super::cvt_err)
     }
 
     fn flush(&mut self) -> io::Result<()> {
@@ -69,7 +69,7 @@ pub fn panic_output() -> Option<impl io::Write> {
 pub(super) unsafe fn init() {
     // Find the UART table
     let mut tbl = None;
-    for (id, info) in super::io::tables() {
+    for (id, info) in rt::table::TableIter::new().unwrap() {
         if info.name() == b"uart" {
             tbl = Some(id);
             break;
@@ -78,7 +78,7 @@ pub(super) unsafe fn init() {
     // If we couldn't find the table, there is absolutely nothing we can do, so just abort.
     let tbl = tbl.unwrap_or_else(|| core::intrinsics::abort());
 
-    STDIN.store(super::io::open(tbl, b"0").unwrap(), Ordering::Relaxed);
-    STDOUT.store(super::io::open(tbl, b"0").unwrap(), Ordering::Relaxed);
-    STDERR.store(super::io::open(tbl, b"0").unwrap(), Ordering::Relaxed);
+    STDIN.store(rt::io::open(tbl, b"0").unwrap(), Ordering::Relaxed);
+    STDOUT.store(rt::io::open(tbl, b"0").unwrap(), Ordering::Relaxed);
+    STDERR.store(rt::io::open(tbl, b"0").unwrap(), Ordering::Relaxed);
 }
diff --git a/library/std/src/sys/norostb/thread.rs b/library/std/src/sys/norostb/thread.rs
index 637b716dff0..e439f997705 100644
--- a/library/std/src/sys/norostb/thread.rs
+++ b/library/std/src/sys/norostb/thread.rs
@@ -1,117 +1,22 @@
 use super::unsupported;
 use crate::ffi::CStr;
 use crate::io;
-use crate::mem;
 use crate::num::NonZeroUsize;
-use crate::ptr;
 use crate::time::Duration;
-use norostb_rt::kernel::io::Handle;
-use norostb_rt::kernel::syscall::{self, RWX};
+use norostb_rt as rt;
 
-pub struct Thread {
-    handle: Handle,
-}
+pub struct Thread(rt::thread::Thread);
 
 pub const DEFAULT_MIN_STACK_SIZE: usize = 4096;
 
 impl Thread {
     // unsafe: see thread::Builder::spawn_unchecked for safety requirements
-    pub unsafe fn new(stack: usize, p: Box<dyn FnOnce()>) -> io::Result<Thread> {
-        // Allocate stack
-        let (stack, stack_size) = syscall::alloc(None, stack, RWX::RW).map_err(|_| {
-            io::const_io_error!(io::ErrorKind::Uncategorized, "failed to allocate stack space")
-        })?;
-        let stack = stack.cast::<u8>();
-
-        // Push closure on the stack of the new thread
-        let (ptr, meta) = Box::into_raw(p).to_raw_parts();
-        let stack_top = stack.as_ptr().wrapping_add(stack_size.get()).cast::<usize>();
-        let mut stack_ptr = stack_top;
-        let mut push = |v: usize| {
-            stack_ptr = stack_ptr.wrapping_sub(1);
-            // SAFETY: we will only push four usizes, which should fit well within a single
-            // page.
-            unsafe {
-                stack_ptr.write(v);
-            }
-        };
-        push(ptr as usize);
-        push(unsafe { mem::transmute(meta) });
-        push(stack.as_ptr() as usize);
-        push(stack_size.get());
-
-        unsafe extern "C" fn main(
-            ptr: *mut (),
-            meta: usize,
-            stack_base: *const (),
-            stack_size: usize,
-            handle: Handle,
-        ) -> ! {
-            let meta = unsafe { mem::transmute(meta) };
-            let p: Box<dyn FnOnce()> = unsafe { Box::from_raw(ptr::from_raw_parts_mut(ptr, meta)) };
-
-            unsafe {
-                super::thread_local_key::init_thread();
-            }
-
-            p();
-
-            unsafe {
-                super::thread_local_key::deinit_thread();
-            }
-
-            // We're going to free the stack, so we need to resort to assembly
-            unsafe {
-                core::arch::asm!(
-                    // Deallocate stack
-                    "syscall",
-                    // Kill current thread
-                    "mov eax, {kill_thread}",
-                    "mov rdi, r12",
-                    "syscall",
-                    kill_thread = const syscall::ID_KILL_THREAD,
-                    in("eax") syscall::ID_DEALLOC,
-                    in("rdi") stack_base,
-                    in("rsi") stack_size,
-                    in("rdx") 0,
-                    // Rust is retarded and doesn't let us specify clobbers with out
-                    // so we have to avoid rax, rdx, rcx and r11 manually *sigh*
-                    in("r12") handle,
-                    options(noreturn, nostack),
-                );
-            }
-        }
-
-        #[naked]
-        unsafe extern "C" fn start() -> ! {
-            unsafe {
-                crate::arch::asm!("
-					mov rdi, [rsp - 8 * 1]
-					mov rsi, [rsp - 8 * 2]
-					mov rdx, [rsp - 8 * 3]
-					mov rcx, [rsp - 8 * 4]
-					mov r8, rax
-					jmp {main}
-					",
-                    main = sym main,
-                    options(noreturn),
-                );
-            }
-        }
-
-        // Spawn thread
-        unsafe {
-            syscall::spawn_thread(start, stack_top as *const ())
-                .map_err(|_| {
-                    syscall::dealloc(stack.cast(), stack_size.get(), false, false).unwrap();
-                    io::const_io_error!(io::ErrorKind::Other, "failed to spawn thread")
-                })
-                .map(|handle| Self { handle })
-        }
+    pub unsafe fn new(stack: usize, p: Box<dyn FnOnce()>) -> io::Result<Self> {
+        unsafe { rt::thread::Thread::new(stack, p).map_err(super::cvt_err).map(Self) }
     }
 
     pub fn yield_now() {
-        syscall::sleep(Duration::ZERO);
+        rt::thread::sleep(Duration::ZERO);
     }
 
     pub fn set_name(_name: &CStr) {
@@ -119,11 +24,11 @@ pub fn set_name(_name: &CStr) {
     }
 
     pub fn sleep(dur: Duration) {
-        syscall::sleep(dur);
+        rt::thread::sleep(dur);
     }
 
     pub fn join(self) {
-        let _ = syscall::wait_thread(self.handle);
+        self.0.wait()
     }
 }
 
diff --git a/library/std/src/sys/norostb/thread_local_key.rs b/library/std/src/sys/norostb/thread_local_key.rs
index 55333804ce6..720c7fe1995 100644
--- a/library/std/src/sys/norostb/thread_local_key.rs
+++ b/library/std/src/sys/norostb/thread_local_key.rs
@@ -1,47 +1,26 @@
 // TODO move part of this to the runtime crate as other languages will need
 // to share the same implementation.
 
-use crate::ptr::NonNull;
 use norostb_rt::tls;
 
 pub type Key = usize;
 
-/// # Safety
-///
-/// This must be called exactly once when a thread is created.
-pub(super) unsafe fn init_thread() {
-    unsafe {
-        tls::init_thread(|s| {
-            NonNull::new(Box::into_raw(Box::<[u8]>::new_uninit_slice(s)) as *mut [u8]).unwrap()
-        })
-    }
-}
-/// # Safety
-///
-/// This must be called exactly once when a thread is created.
-pub(super) unsafe fn deinit_thread() {
-    unsafe {
-        tls::deinit_thread(|p| {
-            Box::from_raw(p.as_ptr());
-        })
-    }
-}
-
 #[inline]
 pub unsafe fn create(dtor: Option<unsafe extern "C" fn(*mut u8)>) -> Key {
+    let dtor = unsafe { core::mem::transmute(dtor) };
     tls::allocate(dtor).expect("failed to allocate TLS slot").0
 }
 
 #[inline]
 pub unsafe fn set(key: Key, value: *mut u8) {
     unsafe {
-        tls::set(tls::Key(key), value);
+        tls::set(tls::Key(key), value.cast());
     }
 }
 
 #[inline]
 pub unsafe fn get(key: Key) -> *mut u8 {
-    unsafe { tls::get(tls::Key(key)) }
+    unsafe { tls::get(tls::Key(key)).cast() }
 }
 
 #[inline]
-- 
2.30.2

