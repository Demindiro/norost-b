From ce8c5e1fed6d29af30cf60c6c7e449856ebea25a Mon Sep 17 00:00:00 2001
From: David Hoppenbrouwers <david@salt-inc.org>
Date: Wed, 4 May 2022 09:14:32 +0200
Subject: [PATCH 38/45] Processs table, driver table, io::share in norostb_rt

---
 Cargo.lock                             | 11 ++++
 Cargo.toml                             |  1 +
 library/std/Cargo.toml                 |  1 +
 library/std/src/sys/norostb/alloc.rs   |  2 +-
 library/std/src/sys/norostb/fs.rs      | 15 +++---
 library/std/src/sys/norostb/mod.rs     |  5 ++
 library/std/src/sys/norostb/net.rs     | 10 ++--
 library/std/src/sys/norostb/process.rs | 69 ++++++++++++++++++--------
 library/std/src/sys/norostb/stdio.rs   | 29 +++--------
 9 files changed, 91 insertions(+), 52 deletions(-)

diff --git a/Cargo.lock b/Cargo.lock
index 45b85f9b21e..698e7d129c3 100644
--- a/Cargo.lock
+++ b/Cargo.lock
@@ -2463,6 +2463,16 @@ dependencies = [
  "rustc-std-workspace-core",
 ]
 
+[[package]]
+name = "norostb_rt_alloc"
+version = "0.1.0"
+dependencies = [
+ "compiler_builtins",
+ "norostb_kernel",
+ "rustc-std-workspace-alloc",
+ "rustc-std-workspace-core",
+]
+
 [[package]]
 name = "ntapi"
 version = "0.3.6"
@@ -4950,6 +4960,7 @@ dependencies = [
  "libc",
  "miniz_oxide",
  "norostb_rt",
+ "norostb_rt_alloc",
  "object 0.26.2",
  "panic_abort",
  "panic_unwind",
diff --git a/Cargo.toml b/Cargo.toml
index 0f98d7de9cf..9f6e6ff4f98 100644
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -135,6 +135,7 @@ rustc-std-workspace-std = { path = 'library/rustc-std-workspace-std' }
 
 # No norostb packages are published to crates.io
 norostb_rt = { path = "../../norost/b/lib/rust/rt" }
+norostb_rt_alloc = { path = "../../norost/b/lib/rust/rt_alloc" }
 
 [patch."https://github.com/rust-lang/rust-clippy"]
 clippy_lints = { path = "src/tools/clippy/clippy_lints" }
diff --git a/library/std/Cargo.toml b/library/std/Cargo.toml
index dec2844a08c..70e16d1f602 100644
--- a/library/std/Cargo.toml
+++ b/library/std/Cargo.toml
@@ -49,6 +49,7 @@ wasi = { version = "0.11.0", features = ['rustc-dep-of-std'], default-features =
 
 [target.'cfg(target_os = "norostb")'.dependencies]
 norostb_rt = { version = "*", default-features = false, features =["rustc-dep-of-std"] }
+norostb_rt_alloc = { version = "*", default-features = false, features =["rustc-dep-of-std"] }
 
 [features]
 backtrace = [
diff --git a/library/std/src/sys/norostb/alloc.rs b/library/std/src/sys/norostb/alloc.rs
index da879fb0b9d..70a82ee098f 100644
--- a/library/std/src/sys/norostb/alloc.rs
+++ b/library/std/src/sys/norostb/alloc.rs
@@ -5,7 +5,7 @@ macro_rules! imp {
         #[inline]
         unsafe fn $fn(&self, $($args:$ty),*) -> $ret {
             unsafe {
-                norostb_rt::alloc::ALLOCATOR.$fn($($args),*)
+                norostb_rt_alloc::Allocator.$fn($($args),*)
             }
         }
     };
diff --git a/library/std/src/sys/norostb/fs.rs b/library/std/src/sys/norostb/fs.rs
index e39561c384d..3749c8709a9 100644
--- a/library/std/src/sys/norostb/fs.rs
+++ b/library/std/src/sys/norostb/fs.rs
@@ -154,11 +154,10 @@ pub fn create_new(&mut self, create_new: bool) {
 
 impl File {
     pub fn open(path: &Path, opts: &OpenOptions) -> io::Result<File> {
-        if opts.create {
-            rt_io::base_object().create(path_inner(path)).map(File).map_err(cvt_err)
-        } else {
-            rt_io::base_object().open(path_inner(path)).map(File).map_err(cvt_err)
-        }
+        let root = rt_io::file_root().ok_or(super::ERR_UNSET)?;
+        if opts.create { root.create(path_inner(path)) } else { root.open(path_inner(path)) }
+            .map(File)
+            .map_err(cvt_err)
     }
 
     pub fn file_attr(&self) -> io::Result<FileAttr> {
@@ -247,7 +246,11 @@ pub fn mkdir(&self, _p: &Path) -> io::Result<()> {
 }
 
 pub fn readdir(path: &Path) -> io::Result<ReadDir> {
-    rt_io::base_object().query(path_inner(path)).map(ReadDir).map_err(cvt_err)
+    rt_io::file_root()
+        .ok_or(super::ERR_UNSET)?
+        .query(path_inner(path))
+        .map(ReadDir)
+        .map_err(cvt_err)
 }
 
 pub fn unlink(_p: &Path) -> io::Result<()> {
diff --git a/library/std/src/sys/norostb/mod.rs b/library/std/src/sys/norostb/mod.rs
index 5f58cbcdb05..6d692d70ba2 100644
--- a/library/std/src/sys/norostb/mod.rs
+++ b/library/std/src/sys/norostb/mod.rs
@@ -69,5 +69,10 @@ fn cvt_err(err: norostb_rt::Error) -> crate::io::Error {
         Error::DoesNotExist => const_io_error!(ErrorKind::NotFound, "does not exist"),
         Error::AlreadyExists => const_io_error!(ErrorKind::AlreadyExists, "already exists"),
         Error::Cancelled => const_io_error!(ErrorKind::Uncategorized, "cancelled"),
+        Error::CantCreateObject => const_io_error!(ErrorKind::InvalidInput, "can't create object"),
+        Error::InvalidObject => const_io_error!(ErrorKind::InvalidInput, "invalid object"),
     }
 }
+
+const ERR_UNSET: crate::io::Error =
+    crate::io::const_io_error!(crate::io::ErrorKind::Uncategorized, "handle is not set");
diff --git a/library/std/src/sys/norostb/net.rs b/library/std/src/sys/norostb/net.rs
index 74e738357c6..879928aca32 100644
--- a/library/std/src/sys/norostb/net.rs
+++ b/library/std/src/sys/norostb/net.rs
@@ -30,9 +30,9 @@ pub struct TcpStream {
 
 impl TcpStream {
     pub fn connect(address: io::Result<&SocketAddr>) -> io::Result<TcpStream> {
-        let (l, p) = netpath!("net/default/tcp/connect/{}/{}", address);
+        let (l, p) = netpath!("default/tcp/connect/{}/{}", address);
         Ok(Self {
-            inner: rt::io::base_object().create(&p[..l]).map_err(cvt_err)?,
+            inner: rt::io::net_root().ok_or(super::ERR_UNSET)?.create(&p[..l]).map_err(cvt_err)?,
             read_timeout: Cell::new(None),
             write_timeout: Cell::new(None),
         })
@@ -151,8 +151,10 @@ pub struct TcpListener {
 
 impl TcpListener {
     pub fn bind(address: io::Result<&SocketAddr>) -> io::Result<TcpListener> {
-        let (l, p) = netpath!("net/{}/tcp/listen/{}", address);
-        Ok(Self { inner: rt::io::base_object().create(&p[..l]).map_err(cvt_err)? })
+        let (l, p) = netpath!("{}/tcp/listen/{}", address);
+        Ok(Self {
+            inner: rt::io::net_root().ok_or(super::ERR_UNSET)?.create(&p[..l]).map_err(cvt_err)?,
+        })
     }
 
     pub fn socket_addr(&self) -> io::Result<SocketAddr> {
diff --git a/library/std/src/sys/norostb/process.rs b/library/std/src/sys/norostb/process.rs
index 344e622ec7a..a086a1a3084 100644
--- a/library/std/src/sys/norostb/process.rs
+++ b/library/std/src/sys/norostb/process.rs
@@ -1,14 +1,15 @@
-use crate::ffi::OsStr;
+use crate::ffi::{OsStr, OsString};
 use crate::fmt;
 use crate::io;
-use crate::marker::PhantomData;
 use crate::num::NonZeroI32;
+use crate::os::norostb::prelude::*;
 use crate::path::Path;
+use crate::slice::Iter;
 use crate::sys::fs::File;
 use crate::sys::pipe::AnonPipe;
 use crate::sys::unsupported;
 use crate::sys_common::process::{CommandEnv, CommandEnvs};
-use norostb_rt::Handle;
+use norostb_rt as rt;
 
 pub use crate::ffi::OsString as EnvKey;
 
@@ -17,7 +18,10 @@
 ////////////////////////////////////////////////////////////////////////////////
 
 pub struct Command {
+    program: OsString,
     env: CommandEnv,
+    dir: OsString,
+    args: Vec<OsString>,
 }
 
 // passed back to std::process with the pipes connected to the child, if any
@@ -35,30 +39,45 @@ pub enum Stdio {
 }
 
 impl Command {
-    pub fn new(_program: &OsStr) -> Command {
-        Command { env: Default::default() }
+    pub fn new(program: &OsStr) -> Self {
+        Self {
+            program: program.into(),
+            env: Default::default(),
+            dir: Default::default(),
+            args: Default::default(),
+        }
     }
 
-    pub fn arg(&mut self, _arg: &OsStr) {}
+    pub fn arg(&mut self, arg: &OsStr) {
+        self.args.push(arg.into());
+    }
 
     pub fn env_mut(&mut self) -> &mut CommandEnv {
         &mut self.env
     }
 
-    pub fn cwd(&mut self, _dir: &OsStr) {}
+    pub fn cwd(&mut self, dir: &OsStr) {
+        self.dir = dir.into();
+    }
 
-    pub fn stdin(&mut self, _stdin: Stdio) {}
+    pub fn stdin(&mut self, _stdin: Stdio) {
+        todo!()
+    }
 
-    pub fn stdout(&mut self, _stdout: Stdio) {}
+    pub fn stdout(&mut self, _stdout: Stdio) {
+        todo!()
+    }
 
-    pub fn stderr(&mut self, _stderr: Stdio) {}
+    pub fn stderr(&mut self, _stderr: Stdio) {
+        todo!()
+    }
 
     pub fn get_program(&self) -> &OsStr {
         panic!("unsupported")
     }
 
     pub fn get_args(&self) -> CommandArgs<'_> {
-        CommandArgs { _p: PhantomData }
+        CommandArgs(self.args.iter())
     }
 
     pub fn get_envs(&self) -> CommandEnvs<'_> {
@@ -74,7 +93,17 @@ pub fn spawn(
         _default: Stdio,
         _needs_stdin: bool,
     ) -> io::Result<(Process, StdioPipes)> {
-        unsupported()
+        rt::Process::new(
+            &rt::io::file_root()
+                .ok_or(super::ERR_UNSET)?
+                .open(self.program.as_bytes())
+                .map_err(super::cvt_err)?,
+            rt::process::Process::default_handles(),
+            self.args.iter().map(|s| s.as_bytes()),
+            self.env.capture().iter().map(|(k, v)| (k.as_bytes(), v.as_bytes())),
+        )
+        .map_err(super::cvt_err)
+        .map(|p| (Process(p), StdioPipes { stdin: None, stdout: None, stderr: None }))
     }
 }
 
@@ -172,13 +201,11 @@ fn from(code: u8) -> Self {
     }
 }
 
-pub struct Process {
-    handle: Handle,
-}
+pub struct Process(rt::Process);
 
 impl Process {
     pub fn id(&self) -> u32 {
-        self.handle
+        self.0.as_object().as_raw()
     }
 
     pub fn kill(&mut self) -> io::Result<()> {
@@ -194,14 +221,16 @@ pub fn try_wait(&mut self) -> io::Result<Option<ExitStatus>> {
     }
 }
 
-pub struct CommandArgs<'a> {
-    _p: PhantomData<&'a ()>,
-}
+pub struct CommandArgs<'a>(Iter<'a, OsString>);
 
 impl<'a> Iterator for CommandArgs<'a> {
     type Item = &'a OsStr;
     fn next(&mut self) -> Option<&'a OsStr> {
-        None
+        self.0.next().map(|s| &**s)
+    }
+
+    fn size_hint(&self) -> (usize, Option<usize>) {
+        self.0.size_hint()
     }
 }
 
diff --git a/library/std/src/sys/norostb/stdio.rs b/library/std/src/sys/norostb/stdio.rs
index aff39df5492..189daacc6c4 100644
--- a/library/std/src/sys/norostb/stdio.rs
+++ b/library/std/src/sys/norostb/stdio.rs
@@ -1,9 +1,5 @@
-use crate::{io, sync::atomic::Ordering};
-use norostb_rt::{self as rt, AtomicHandle};
-
-static STDIN: AtomicHandle = AtomicHandle::new(0);
-static STDOUT: AtomicHandle = AtomicHandle::new(0);
-static STDERR: AtomicHandle = AtomicHandle::new(0);
+use crate::io;
+use norostb_rt as rt;
 
 pub struct Stdin;
 pub struct Stdout;
@@ -19,7 +15,7 @@ pub const fn new() -> Stdin {
 
 impl io::Read for Stdin {
     fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {
-        rt::io::read(STDIN.load(Ordering::Relaxed), buf).map_err(super::cvt_err)
+        rt::io::stdin().ok_or(super::ERR_UNSET)?.read(buf).map_err(super::cvt_err)
     }
 }
 
@@ -31,7 +27,8 @@ pub const fn new() -> Stdout {
 
 impl io::Write for Stdout {
     fn write(&mut self, buf: &[u8]) -> io::Result<usize> {
-        rt::io::write(STDOUT.load(Ordering::Relaxed), buf).map_err(super::cvt_err)
+        unsafe { core::arch::asm!("int3") }
+        rt::io::stdout().ok_or(super::ERR_UNSET)?.write(buf).map_err(super::cvt_err)
     }
 
     fn flush(&mut self) -> io::Result<()> {
@@ -47,7 +44,7 @@ pub const fn new() -> Stderr {
 
 impl io::Write for Stderr {
     fn write(&mut self, buf: &[u8]) -> io::Result<usize> {
-        rt::io::write(STDERR.load(Ordering::Relaxed), buf).map_err(super::cvt_err)
+        rt::io::stderr().ok_or(super::ERR_UNSET)?.write(buf).map_err(super::cvt_err)
     }
 
     fn flush(&mut self) -> io::Result<()> {
@@ -60,20 +57,10 @@ pub fn is_ebadf(_err: &io::Error) -> bool {
 }
 
 pub fn panic_output() -> Option<impl io::Write> {
-    Some(Stderr)
+    rt::io::stderr().map(|_| Stderr)
 }
 
 /// # Safety
 ///
 /// Must be called only once during runtime initialization.
-pub(super) unsafe fn init() {
-    let f = || {
-        rt::io::base_object()
-            .open(b"uart/0")
-            .unwrap_or_else(|_| core::intrinsics::abort())
-            .into_raw()
-    };
-    STDIN.store(f(), Ordering::Relaxed);
-    STDOUT.store(f(), Ordering::Relaxed);
-    STDERR.store(f(), Ordering::Relaxed);
-}
+pub(super) unsafe fn init() {}
-- 
2.30.2

