From e36b549d0cc9c66f4e851f984f0dbd403d04e260 Mon Sep 17 00:00:00 2001
From: David Hoppenbrouwers <david@salt-inc.org>
Date: Sat, 30 Apr 2022 11:42:00 +0200
Subject: [PATCH 37/45] Partially implement net

---
 library/std/src/sys/norostb/net.rs | 236 +++++++++++++++++------------
 1 file changed, 139 insertions(+), 97 deletions(-)

diff --git a/library/std/src/sys/norostb/net.rs b/library/std/src/sys/norostb/net.rs
index dbb6ce22c22..74e738357c6 100644
--- a/library/std/src/sys/norostb/net.rs
+++ b/library/std/src/sys/norostb/net.rs
@@ -1,301 +1,342 @@
+use super::cvt_err;
+use crate::cell::Cell;
 use crate::convert::TryFrom;
-use crate::fmt;
-use crate::io::{self, IoSlice, IoSliceMut};
+use crate::io::{self, IoSlice, IoSliceMut, Write};
 use crate::net::{Ipv4Addr, Ipv6Addr, Shutdown, SocketAddr};
 use crate::sys::unsupported;
 use crate::time::Duration;
+use norostb_rt as rt;
 
-pub struct TcpStream(!);
+#[derive(Debug)]
+pub struct TcpStream {
+    inner: rt::Object,
+    read_timeout: Cell<Option<Duration>>,
+    write_timeout: Cell<Option<Duration>>,
+}
+
+macro netpath($fmt:literal, $addr:ident) {{
+    let addr = $addr?;
+    let ip = match addr {
+        SocketAddr::V4(a) => a.ip().to_ipv6_mapped(),
+        SocketAddr::V6(a) => *a.ip(),
+    };
+    // 128 bytes ought to be plenty.
+    let mut path = [0; 128];
+    let mut p = &mut path[..];
+    write!(p, $fmt, ip, addr.port()).unwrap();
+    let l = p.len();
+    (path.len() - l, path)
+}}
 
 impl TcpStream {
-    pub fn connect(_: io::Result<&SocketAddr>) -> io::Result<TcpStream> {
-        unsupported()
+    pub fn connect(address: io::Result<&SocketAddr>) -> io::Result<TcpStream> {
+        let (l, p) = netpath!("net/default/tcp/connect/{}/{}", address);
+        Ok(Self {
+            inner: rt::io::base_object().create(&p[..l]).map_err(cvt_err)?,
+            read_timeout: Cell::new(None),
+            write_timeout: Cell::new(None),
+        })
     }
 
-    pub fn connect_timeout(_: &SocketAddr, _: Duration) -> io::Result<TcpStream> {
+    pub fn connect_timeout(_address: &SocketAddr, _timeout: Duration) -> io::Result<TcpStream> {
         unsupported()
     }
 
-    pub fn set_read_timeout(&self, _: Option<Duration>) -> io::Result<()> {
-        self.0
+    pub fn set_read_timeout(&self, timeout: Option<Duration>) -> io::Result<()> {
+        self.read_timeout.set(timeout);
+        Ok(())
     }
 
-    pub fn set_write_timeout(&self, _: Option<Duration>) -> io::Result<()> {
-        self.0
+    pub fn set_write_timeout(&self, timeout: Option<Duration>) -> io::Result<()> {
+        self.write_timeout.set(timeout);
+        Ok(())
     }
 
     pub fn read_timeout(&self) -> io::Result<Option<Duration>> {
-        self.0
+        Ok(self.read_timeout.get())
     }
 
     pub fn write_timeout(&self) -> io::Result<Option<Duration>> {
-        self.0
+        Ok(self.write_timeout.get())
     }
 
-    pub fn peek(&self, _: &mut [u8]) -> io::Result<usize> {
-        self.0
+    pub fn peek(&self, data: &mut [u8]) -> io::Result<usize> {
+        self.inner.peek(data).map_err(cvt_err)
     }
 
-    pub fn read(&self, _: &mut [u8]) -> io::Result<usize> {
-        self.0
+    pub fn read(&self, data: &mut [u8]) -> io::Result<usize> {
+        self.inner.read(data).map_err(cvt_err)
     }
 
-    pub fn read_vectored(&self, _: &mut [IoSliceMut<'_>]) -> io::Result<usize> {
-        self.0
+    pub fn read_vectored(&self, _data: &mut [IoSliceMut<'_>]) -> io::Result<usize> {
+        unsupported()
     }
 
     pub fn is_read_vectored(&self) -> bool {
-        self.0
+        false
     }
 
-    pub fn write(&self, _: &[u8]) -> io::Result<usize> {
-        self.0
+    pub fn write(&self, data: &[u8]) -> io::Result<usize> {
+        self.inner.write(data).map_err(cvt_err)
     }
 
-    pub fn write_vectored(&self, _: &[IoSlice<'_>]) -> io::Result<usize> {
-        self.0
+    pub fn write_vectored(&self, _data: &[IoSlice<'_>]) -> io::Result<usize> {
+        unsupported()
     }
 
     pub fn is_write_vectored(&self) -> bool {
-        self.0
+        false
     }
 
     pub fn peer_addr(&self) -> io::Result<SocketAddr> {
-        self.0
+        unsupported()
     }
 
     pub fn socket_addr(&self) -> io::Result<SocketAddr> {
-        self.0
+        unsupported()
     }
 
     pub fn shutdown(&self, _: Shutdown) -> io::Result<()> {
-        self.0
+        unsupported()
     }
 
     pub fn duplicate(&self) -> io::Result<TcpStream> {
-        self.0
+        self.inner
+            .duplicate()
+            .map(|inner| Self {
+                inner,
+                read_timeout: self.read_timeout.clone(),
+                write_timeout: self.write_timeout.clone(),
+            })
+            .map_err(cvt_err)
     }
 
     pub fn set_linger(&self, _: Option<Duration>) -> io::Result<()> {
-        self.0
+        unsupported()
     }
 
     pub fn linger(&self) -> io::Result<Option<Duration>> {
-        self.0
+        unsupported()
     }
 
     pub fn set_nodelay(&self, _: bool) -> io::Result<()> {
-        self.0
+        unsupported()
     }
 
     pub fn nodelay(&self) -> io::Result<bool> {
-        self.0
+        unsupported()
     }
 
     pub fn set_ttl(&self, _: u32) -> io::Result<()> {
-        self.0
+        unsupported()
     }
 
     pub fn ttl(&self) -> io::Result<u32> {
-        self.0
+        unsupported()
     }
 
     pub fn take_error(&self) -> io::Result<Option<io::Error>> {
-        self.0
+        unsupported()
     }
 
     pub fn set_nonblocking(&self, _: bool) -> io::Result<()> {
-        self.0
+        unsupported()
     }
 }
 
-impl fmt::Debug for TcpStream {
-    fn fmt(&self, _f: &mut fmt::Formatter<'_>) -> fmt::Result {
-        self.0
-    }
+#[derive(Debug)]
+pub struct TcpListener {
+    inner: rt::Object,
 }
 
-pub struct TcpListener(!);
-
 impl TcpListener {
-    pub fn bind(_: io::Result<&SocketAddr>) -> io::Result<TcpListener> {
-        unsupported()
+    pub fn bind(address: io::Result<&SocketAddr>) -> io::Result<TcpListener> {
+        let (l, p) = netpath!("net/{}/tcp/listen/{}", address);
+        Ok(Self { inner: rt::io::base_object().create(&p[..l]).map_err(cvt_err)? })
     }
 
     pub fn socket_addr(&self) -> io::Result<SocketAddr> {
-        self.0
+        unsupported()
     }
 
     pub fn accept(&self) -> io::Result<(TcpStream, SocketAddr)> {
-        self.0
+        self.inner.open(b"accept").map_err(cvt_err).and_then(|inner| {
+            let peer =
+                TcpStream { inner, read_timeout: Cell::new(None), write_timeout: Cell::new(None) };
+            // FIXME
+            Ok((peer, "0.0.0.0:0".parse().unwrap()))
+            //peer.socket_addr().map(|addr| (peer, addr))
+        })
     }
 
     pub fn duplicate(&self) -> io::Result<TcpListener> {
-        self.0
+        unsupported()
     }
 
     pub fn set_ttl(&self, _: u32) -> io::Result<()> {
-        self.0
+        unsupported()
     }
 
     pub fn ttl(&self) -> io::Result<u32> {
-        self.0
+        unsupported()
     }
 
+    // The corresponding function still exists in std::net::TcpStream but is deprecated and
+    // hidden from the docs, so we don't need to support it ever.
     pub fn set_only_v6(&self, _: bool) -> io::Result<()> {
-        self.0
+        unsupported()
     }
 
+    // Ditto
     pub fn only_v6(&self) -> io::Result<bool> {
-        self.0
+        unsupported()
     }
 
     pub fn take_error(&self) -> io::Result<Option<io::Error>> {
-        self.0
+        unsupported()
     }
 
     pub fn set_nonblocking(&self, _: bool) -> io::Result<()> {
-        self.0
+        unsupported()
     }
 }
 
-impl fmt::Debug for TcpListener {
-    fn fmt(&self, _f: &mut fmt::Formatter<'_>) -> fmt::Result {
-        self.0
-    }
+#[derive(Debug)]
+pub struct UdpSocket {
+    inner: super::fs::File,
+    read_timeout: Cell<Option<Duration>>,
+    write_timeout: Cell<Option<Duration>>,
 }
 
-pub struct UdpSocket(!);
-
 impl UdpSocket {
     pub fn bind(_: io::Result<&SocketAddr>) -> io::Result<UdpSocket> {
         unsupported()
     }
 
     pub fn peer_addr(&self) -> io::Result<SocketAddr> {
-        self.0
+        unsupported()
     }
 
     pub fn socket_addr(&self) -> io::Result<SocketAddr> {
-        self.0
+        unsupported()
     }
 
     pub fn recv_from(&self, _: &mut [u8]) -> io::Result<(usize, SocketAddr)> {
-        self.0
+        unsupported()
     }
 
     pub fn peek_from(&self, _: &mut [u8]) -> io::Result<(usize, SocketAddr)> {
-        self.0
+        unsupported()
     }
 
     pub fn send_to(&self, _: &[u8], _: &SocketAddr) -> io::Result<usize> {
-        self.0
+        unsupported()
     }
 
     pub fn duplicate(&self) -> io::Result<UdpSocket> {
-        self.0
+        self.inner.duplicate().map(|inner| Self {
+            inner,
+            read_timeout: self.read_timeout.clone(),
+            write_timeout: self.write_timeout.clone(),
+        })
     }
 
-    pub fn set_read_timeout(&self, _: Option<Duration>) -> io::Result<()> {
-        self.0
+    pub fn set_read_timeout(&self, timeout: Option<Duration>) -> io::Result<()> {
+        self.read_timeout.set(timeout);
+        Ok(())
     }
 
-    pub fn set_write_timeout(&self, _: Option<Duration>) -> io::Result<()> {
-        self.0
+    pub fn set_write_timeout(&self, timeout: Option<Duration>) -> io::Result<()> {
+        self.write_timeout.set(timeout);
+        Ok(())
     }
 
     pub fn read_timeout(&self) -> io::Result<Option<Duration>> {
-        self.0
+        Ok(self.read_timeout.get())
     }
 
     pub fn write_timeout(&self) -> io::Result<Option<Duration>> {
-        self.0
+        Ok(self.write_timeout.get())
     }
 
     pub fn set_broadcast(&self, _: bool) -> io::Result<()> {
-        self.0
+        unsupported()
     }
 
     pub fn broadcast(&self) -> io::Result<bool> {
-        self.0
+        unsupported()
     }
 
     pub fn set_multicast_loop_v4(&self, _: bool) -> io::Result<()> {
-        self.0
+        unsupported()
     }
 
     pub fn multicast_loop_v4(&self) -> io::Result<bool> {
-        self.0
+        unsupported()
     }
 
     pub fn set_multicast_ttl_v4(&self, _: u32) -> io::Result<()> {
-        self.0
+        unsupported()
     }
 
     pub fn multicast_ttl_v4(&self) -> io::Result<u32> {
-        self.0
+        unsupported()
     }
 
     pub fn set_multicast_loop_v6(&self, _: bool) -> io::Result<()> {
-        self.0
+        unsupported()
     }
 
     pub fn multicast_loop_v6(&self) -> io::Result<bool> {
-        self.0
+        unsupported()
     }
 
     pub fn join_multicast_v4(&self, _: &Ipv4Addr, _: &Ipv4Addr) -> io::Result<()> {
-        self.0
+        unsupported()
     }
 
     pub fn join_multicast_v6(&self, _: &Ipv6Addr, _: u32) -> io::Result<()> {
-        self.0
+        unsupported()
     }
 
     pub fn leave_multicast_v4(&self, _: &Ipv4Addr, _: &Ipv4Addr) -> io::Result<()> {
-        self.0
+        unsupported()
     }
 
     pub fn leave_multicast_v6(&self, _: &Ipv6Addr, _: u32) -> io::Result<()> {
-        self.0
+        unsupported()
     }
 
     pub fn set_ttl(&self, _: u32) -> io::Result<()> {
-        self.0
+        unsupported()
     }
 
     pub fn ttl(&self) -> io::Result<u32> {
-        self.0
+        unsupported()
     }
 
     pub fn take_error(&self) -> io::Result<Option<io::Error>> {
-        self.0
+        unsupported()
     }
 
     pub fn set_nonblocking(&self, _: bool) -> io::Result<()> {
-        self.0
+        unsupported()
     }
 
     pub fn recv(&self, _: &mut [u8]) -> io::Result<usize> {
-        self.0
+        unsupported()
     }
 
     pub fn peek(&self, _: &mut [u8]) -> io::Result<usize> {
-        self.0
+        unsupported()
     }
 
     pub fn send(&self, _: &[u8]) -> io::Result<usize> {
-        self.0
+        unsupported()
     }
 
     pub fn connect(&self, _: io::Result<&SocketAddr>) -> io::Result<()> {
-        self.0
-    }
-}
-
-impl fmt::Debug for UdpSocket {
-    fn fmt(&self, _f: &mut fmt::Formatter<'_>) -> fmt::Result {
-        self.0
+        unsupported()
     }
 }
 
@@ -330,6 +371,7 @@ fn try_from(_v: (&'a str, u16)) -> io::Result<LookupHost> {
     }
 }
 
+/// Used by [`std::net::addr`].
 #[allow(nonstandard_style)]
 pub mod netc {
     pub const AF_INET: u8 = 0;
-- 
2.30.2

