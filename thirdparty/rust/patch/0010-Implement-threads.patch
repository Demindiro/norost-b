From 923c2f224d74437d9fc889028c12d6d796555d05 Mon Sep 17 00:00:00 2001
From: David Hoppenbrouwers <david@salt-inc.org>
Date: Tue, 8 Mar 2022 00:07:47 +0100
Subject: [PATCH 10/47] Implement threads

---
 Cargo.lock                                    |  1 +
 library/std/src/lib.rs                        | 17 +++++
 library/std/src/sys/norostb/fs.rs             |  4 +-
 library/std/src/sys/norostb/mod.rs            |  6 +-
 library/std/src/sys/norostb/thread.rs         | 75 ++++++++++++++++++-
 .../std/src/sys/norostb/thread_local_key.rs   | 45 ++++++-----
 6 files changed, 118 insertions(+), 30 deletions(-)

diff --git a/Cargo.lock b/Cargo.lock
index 5407223384c..45b85f9b21e 100644
--- a/Cargo.lock
+++ b/Cargo.lock
@@ -2459,6 +2459,7 @@ dependencies = [
  "cfg-if 1.0.0",
  "compiler_builtins",
  "norostb_kernel",
+ "rustc-std-workspace-alloc",
  "rustc-std-workspace-core",
 ]
 
diff --git a/library/std/src/lib.rs b/library/std/src/lib.rs
index 6dc3fd98584..5acce889961 100644
--- a/library/std/src/lib.rs
+++ b/library/std/src/lib.rs
@@ -224,6 +224,16 @@
 #![feature(allocator_internals)]
 #![feature(allow_internal_unsafe)]
 #![feature(allow_internal_unstable)]
+#![feature(arbitrary_self_types)]
+#![feature(array_error_internals)]
+#![feature(asm_sym)]
+#![feature(assert_matches)]
+#![feature(associated_type_bounds)]
+#![feature(async_iterator)]
+#![feature(atomic_mut_ptr)]
+#![feature(auto_traits)]
+#![feature(bench_black_box)]
+#![feature(bool_to_option)]
 #![feature(box_syntax)]
 #![feature(c_unwind)]
 #![feature(cfg_target_thread_local)]
@@ -244,6 +254,7 @@
 #![feature(linkage)]
 #![feature(min_specialization)]
 #![feature(must_not_suspend)]
+#![feature(naked_functions)]
 #![feature(needs_panic_runtime)]
 #![feature(negative_impls)]
 #![feature(never_type)]
@@ -284,6 +295,12 @@
 #![feature(prelude_2024)]
 #![feature(ptr_as_uninit)]
 #![feature(raw_os_nonzero)]
+#![feature(ptr_internals)]
+#![feature(ptr_metadata)]
+#![feature(rustc_attrs)]
+#![feature(rustc_private)]
+#![feature(saturating_int_impl)]
+#![feature(slice_concat_ext)]
 #![feature(slice_internals)]
 #![feature(slice_ptr_get)]
 #![feature(std_internals)]
diff --git a/library/std/src/sys/norostb/fs.rs b/library/std/src/sys/norostb/fs.rs
index 7587e52af35..0a849a630a4 100644
--- a/library/std/src/sys/norostb/fs.rs
+++ b/library/std/src/sys/norostb/fs.rs
@@ -332,7 +332,9 @@ pub fn seek(&self, _pos: SeekFrom) -> io::Result<u64> {
     }
 
     pub fn duplicate(&self) -> io::Result<File> {
-        unsupported()
+        syscall::duplicate_handle(self.handle)
+            .map_err(|_| io::const_io_error!(io::ErrorKind::Uncategorized, "TODO failed duplicate"))
+            .map(|handle| Self { handle })
     }
 
     pub fn set_permissions(&self, _perm: FilePermissions) -> io::Result<()> {
diff --git a/library/std/src/sys/norostb/mod.rs b/library/std/src/sys/norostb/mod.rs
index 1b551f8c087..bc7266f2559 100644
--- a/library/std/src/sys/norostb/mod.rs
+++ b/library/std/src/sys/norostb/mod.rs
@@ -45,7 +45,11 @@ pub extern "C" fn __rust_abort() {
 ///
 /// This is not guaranteed to run, for example when Rust code is called externally.
 pub unsafe fn init(_argc: isize, _argv: *const *const u8) {
-    unsafe { stdio::init() }
+    // FIXME this is not guaranteed to run.
+    unsafe {
+        thread_local_key::init_thread();
+        stdio::init();
+    }
 }
 
 /// # Safety
diff --git a/library/std/src/sys/norostb/thread.rs b/library/std/src/sys/norostb/thread.rs
index 1f9475515ca..3a902baabef 100644
--- a/library/std/src/sys/norostb/thread.rs
+++ b/library/std/src/sys/norostb/thread.rs
@@ -1,18 +1,85 @@
 use super::unsupported;
 use crate::ffi::CStr;
 use crate::io;
+use crate::mem;
 use crate::num::NonZeroUsize;
+use crate::ptr;
 use crate::time::Duration;
 use norostb_rt::kernel::syscall;
 
-pub struct Thread(!);
+pub struct Thread {
+    handle: usize,
+}
 
 pub const DEFAULT_MIN_STACK_SIZE: usize = 4096;
 
 impl Thread {
     // unsafe: see thread::Builder::spawn_unchecked for safety requirements
-    pub unsafe fn new(_stack: usize, _p: Box<dyn FnOnce()>) -> io::Result<Thread> {
-        unsupported()
+    pub unsafe fn new(stack: usize, p: Box<dyn FnOnce()>) -> io::Result<Thread> {
+        #[cfg(any(target_arch = "x86", target_arch = "x86_64"))]
+        #[repr(align(16))]
+        struct E([u8; 16]);
+        #[cfg(not(any(target_arch = "x86", target_arch = "x86_64")))]
+        compile_error!("unknown stack alignment requirements");
+
+        // Allocate stack
+        let stack = (stack + mem::size_of::<E>() - 1) / mem::size_of::<E>();
+        // FIXME we need to allocate new pages so we can use stack guards. Allocating from
+        // the global allocator puts us at risk of overflowing into other buffers and corrupting
+        // those.
+        let mut stack = Box::<[E]>::try_new_uninit_slice(stack)
+            .map_err(|e| io::Error::new(io::ErrorKind::OutOfMemory, e))?;
+
+        // Push closure on the stack of the new thread
+        let (ptr, meta) = Box::into_raw(p).to_raw_parts();
+        let stack_top = stack.as_mut_ptr().wrapping_add(stack.len()).cast::<usize>();
+        let mut stack_ptr = stack_top;
+        let mut push = |v: usize| {
+            stack_ptr = stack_ptr.wrapping_sub(1);
+            // SAFETY: we will hit a guard page and crash without UB if we go out of bounds
+            // (we actually don't, see FIXME above)
+            unsafe {
+                stack_ptr.write(v);
+            }
+        };
+        push(ptr as usize);
+        push(unsafe { mem::transmute(meta) });
+
+        unsafe extern "C" fn main(ptr: *mut (), meta: usize) -> ! {
+            let meta = unsafe { mem::transmute(meta) };
+            let p: Box<dyn FnOnce()> = unsafe { Box::from_raw(ptr::from_raw_parts_mut(ptr, meta)) };
+
+            unsafe {
+                super::thread_local_key::init_thread();
+            }
+
+            p();
+
+            loop {
+                syscall::sleep(crate::time::Duration::MAX);
+            }
+        }
+
+        #[naked]
+        unsafe extern "C" fn start() -> ! {
+            unsafe {
+                crate::arch::asm!("
+					mov rdi, [rsp - 8 * 1]
+					mov rsi, [rsp - 8 * 2]
+					jmp {main}
+					",
+                    main = sym main,
+                    options(noreturn),
+                );
+            }
+        }
+
+        // Spawn thread
+        unsafe {
+            syscall::spawn_thread(start, stack_top as *const ())
+                .map_err(|_| io::const_io_error!(io::ErrorKind::Other, "failed to spawn thread"))
+                .map(|handle| Self { handle })
+        }
     }
 
     pub fn yield_now() {
@@ -28,7 +95,7 @@ pub fn sleep(dur: Duration) {
     }
 
     pub fn join(self) {
-        self.0
+        todo!("join thread {}", self.handle);
     }
 }
 
diff --git a/library/std/src/sys/norostb/thread_local_key.rs b/library/std/src/sys/norostb/thread_local_key.rs
index a31a3944a06..458124bd4b3 100644
--- a/library/std/src/sys/norostb/thread_local_key.rs
+++ b/library/std/src/sys/norostb/thread_local_key.rs
@@ -1,47 +1,44 @@
-use crate::ptr;
+// TODO move part of this to the runtime crate as other languages will need
+// to share the same implementation.
+
+use crate::ptr::NonNull;
+use norostb_rt::tls;
 
 pub type Key = usize;
 
-// FIXME implement real TLS
-static mut TLS: Vec<(*mut u8, Option<unsafe extern "C" fn(*mut u8)>)> = Vec::new();
+/// # Safety
+///
+/// This must be called exactly once when a thread is created.
+pub(super) unsafe fn init_thread() {
+    unsafe {
+        tls::init_thread::<_, ()>(|s| {
+            Ok(NonNull::new(Box::into_raw(Box::<[u8]>::new_uninit_slice(s)) as *mut *mut ())
+                .unwrap())
+        })
+        .expect("failed to initialize TLS storage");
+    }
+}
 
 #[inline]
 pub unsafe fn create(dtor: Option<unsafe extern "C" fn(*mut u8)>) -> Key {
-    unsafe {
-        TLS.push((ptr::null_mut(), dtor));
-        TLS.len() - 1
-    }
+    tls::allocate(dtor).expect("failed to allocate TLS slot").0
 }
 
 #[inline]
 pub unsafe fn set(key: Key, value: *mut u8) {
-    // TODO do we have to call the destructor on the old value?
     unsafe {
-        debug_assert!(key < TLS.len());
-        TLS.get_unchecked_mut(key).0 = value;
+        tls::set(tls::Key(key), value);
     }
 }
 
 #[inline]
 pub unsafe fn get(key: Key) -> *mut u8 {
-    unsafe {
-        debug_assert!(key < TLS.len());
-        TLS.get_unchecked(key).0
-    }
+    unsafe { tls::get(tls::Key(key)) }
 }
 
 #[inline]
 pub unsafe fn destroy(key: Key) {
-    unsafe {
-        debug_assert!(key < TLS.len());
-        let p = TLS.get_unchecked(key);
-        if let Some(f) = p.1 {
-            if !p.0.is_null() {
-                f(p.0);
-            }
-        }
-        let _ = p;
-    }
+    unsafe { tls::free(tls::Key(key)) }
 }
 
 #[inline]
-- 
2.30.2

