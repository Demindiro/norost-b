From 8ed06da4122de517a7c0ca4c4ab504a88dfca7fa Mon Sep 17 00:00:00 2001
From: David Hoppenbrouwers <david@salt-inc.org>
Date: Thu, 28 Apr 2022 21:25:39 +0200
Subject: [PATCH 35/48] Tables are dead, long live the tables

---
 library/std/src/os/norostb/mod.rs    |   2 +-
 library/std/src/sys/norostb/fs.rs    | 205 +++------------------------
 library/std/src/sys/norostb/stdio.rs |  23 ++-
 3 files changed, 31 insertions(+), 199 deletions(-)

diff --git a/library/std/src/os/norostb/mod.rs b/library/std/src/os/norostb/mod.rs
index 2cb85e49d2f..a06c561b91c 100644
--- a/library/std/src/os/norostb/mod.rs
+++ b/library/std/src/os/norostb/mod.rs
@@ -5,6 +5,6 @@
 
 pub mod prelude {
     use super::*;
-    pub use ffi::OsStrExt;
+    pub use ffi::{OsStrExt, OsStringExt};
     pub use io::{AsHandle, FromHandle, Handle, IntoHandle};
 }
diff --git a/library/std/src/sys/norostb/fs.rs b/library/std/src/sys/norostb/fs.rs
index 463930f15a0..e39561c384d 100644
--- a/library/std/src/sys/norostb/fs.rs
+++ b/library/std/src/sys/norostb/fs.rs
@@ -17,41 +17,24 @@
 use crate::ffi::OsString;
 use crate::hash::Hash;
 use crate::io::{self, IoSlice, IoSliceMut, ReadBuf, SeekFrom};
-use crate::mem;
+use crate::os::norostb::prelude::*;
 use crate::path::{Path, PathBuf};
-use crate::sys::os_str::Buf;
 use crate::sys::time::SystemTime;
 use crate::sys::unsupported;
-use crate::sys_common::{AsInner, FromInner};
-use norostb_rt::{
-    io as rt_io,
-    table::{Object, ObjectInfo, TableId, TableInfo, TableIter},
-    Handle,
-};
+use crate::sys_common::AsInner;
+use norostb_rt::{io as rt_io, table::Object};
 
 #[derive(Debug)]
 pub struct File(pub(crate) Object);
 
-const TABLE_OBJECT_SEPARATOR: u8 = b'/';
-
 #[derive(Clone, Debug)]
-pub enum FileAttr {
-    Table { entries: u64 },
-    Object { size: u64 },
-}
+pub enum FileAttr {}
 
 #[derive(Debug)]
-pub enum ReadDir {
-    None,
-    Tables(TableIter),
-    Objects { table_id: TableId, table_info: TableInfo, query: Handle },
-}
+pub struct ReadDir(rt_io::Query);
 
 #[derive(Clone, Debug)]
-pub enum DirEntry {
-    Table { id: TableId, info: TableInfo },
-    Object { table_id: TableId, table_info: TableInfo, name: OsString },
-}
+pub struct DirEntry(OsString);
 
 #[derive(Clone, Debug)]
 pub struct OpenOptions {
@@ -63,7 +46,6 @@ pub struct OpenOptions {
 
 #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
 pub enum FileType {
-    Table,
     Object,
 }
 
@@ -73,8 +55,7 @@ pub struct DirBuilder {}
 impl FileAttr {
     pub fn size(&self) -> u64 {
         match self {
-            Self::Table { entries, .. } => *entries,
-            Self::Object { size, .. } => *size,
+            _ => unreachable!(),
         }
     }
 
@@ -83,10 +64,7 @@ pub fn perm(&self) -> FilePermissions {
     }
 
     pub fn file_type(&self) -> FileType {
-        match self {
-            Self::Table { .. } => FileType::Table,
-            Self::Object { .. } => FileType::Object,
-        }
+        FileType::Object
     }
 
     pub fn modified(&self) -> io::Result<SystemTime> {
@@ -113,21 +91,18 @@ pub fn set_readonly(&mut self, _readonly: bool) {}
 impl FileType {
     pub fn is_dir(&self) -> bool {
         match self {
-            Self::Table => true,
             Self::Object => false,
         }
     }
 
     pub fn is_file(&self) -> bool {
         match self {
-            Self::Table => false,
             Self::Object => true,
         }
     }
 
     pub fn is_symlink(&self) -> bool {
         match self {
-            Self::Table => false,
             Self::Object => false,
         }
     }
@@ -137,73 +112,26 @@ impl Iterator for ReadDir {
     type Item = io::Result<DirEntry>;
 
     fn next(&mut self) -> Option<io::Result<DirEntry>> {
-        match mem::replace(self, Self::None) {
-            Self::None => None,
-            Self::Tables(mut tbl) => tbl.next().map(|(id, info)| {
-                *self = Self::Tables(tbl);
-                Ok(DirEntry::Table { id, info })
-            }),
-            Self::Objects { table_id, table_info, query } => {
-                let mut inner = Vec::with_capacity(4096);
-                inner.resize(4096, 0);
-                let mut info = ObjectInfo::new(&mut inner);
-                match rt_io::query_next(query, &mut info) {
-                    Ok(true) => {
-                        inner.resize(info.path_len, 0);
-                        let name = OsString::from_inner(Buf { inner }).into();
-                        *self = Self::Objects { table_id, table_info: table_info.clone(), query };
-                        Some(Ok(DirEntry::Object { table_id, table_info, name }))
-                    }
-                    Ok(false) => None,
-                    Err(_) => unreachable!("kernel returned unknown error code"),
-                }
-            }
-        }
+        self.0.next().map(|path| Ok(DirEntry(OsString::from_vec(path))))
     }
 }
 
 impl DirEntry {
     pub fn path(&self) -> PathBuf {
-        match self {
-            Self::Table { info, .. } => {
-                let inner = info.name().into();
-                OsString::from_inner(Buf { inner }).into()
-            }
-            Self::Object { table_info, name, .. } => {
-                let inner = table_info
-                    .name()
-                    .iter()
-                    .chain(&[TABLE_OBJECT_SEPARATOR])
-                    .chain(&name.as_inner().inner)
-                    .copied()
-                    .collect();
-                OsString::from_inner(Buf { inner }).into()
-            }
-        }
+        self.0.clone().into()
     }
 
     pub fn file_name(&self) -> OsString {
-        match self {
-            Self::Table { info, .. } => {
-                let inner = info.name().iter().copied().collect();
-                OsString::from_inner(Buf { inner }).into()
-            }
-            Self::Object { name, .. } => name.clone(),
-        }
+        // TODO this isn't quite accurate.
+        self.0.clone().into()
     }
 
     pub fn metadata(&self) -> io::Result<FileAttr> {
-        match self {
-            Self::Table { .. } => Ok(FileAttr::Table { entries: 0 }),
-            Self::Object { .. } => Ok(FileAttr::Object { size: 0 }),
-        }
+        unsupported()
     }
 
     pub fn file_type(&self) -> io::Result<FileType> {
-        match self {
-            Self::Table { .. } => Ok(FileType::Table),
-            Self::Object { .. } => Ok(FileType::Object),
-        }
+        unsupported()
     }
 }
 
@@ -227,20 +155,9 @@ pub fn create_new(&mut self, create_new: bool) {
 impl File {
     pub fn open(path: &Path, opts: &OpenOptions) -> io::Result<File> {
         if opts.create {
-            // syscall::create takes only a table ID and a string representing path
-            let mut path = path_inner(path).splitn(2, |c| *c == b'/');
-            let table = path.next().expect("at least one match");
-            let path = if let Some(p) = path.next() {
-                p
-            } else {
-                return Err(io::const_io_error!(io::ErrorKind::Other, "expected full path"));
-            };
-            let table = find_table(table)?.0;
-            Object::create(table, path).map(File).map_err(cvt_err)
+            rt_io::base_object().create(path_inner(path)).map(File).map_err(cvt_err)
         } else {
-            // Find a unique ID
-            let (table_id, path) = split_into_table_and_path(path)?;
-            Object::open(table_id, path).map(File).map_err(cvt_err)
+            rt_io::base_object().open(path_inner(path)).map(File).map_err(cvt_err)
         }
     }
 
@@ -249,13 +166,11 @@ pub fn file_attr(&self) -> io::Result<FileAttr> {
     }
 
     pub fn fsync(&self) -> io::Result<()> {
-        // TODO
-        Ok(())
+        unsupported()
     }
 
     pub fn datasync(&self) -> io::Result<()> {
-        // TODO
-        Ok(())
+        unsupported()
     }
 
     pub fn truncate(&self, _size: u64) -> io::Result<()> {
@@ -332,19 +247,7 @@ pub fn mkdir(&self, _p: &Path) -> io::Result<()> {
 }
 
 pub fn readdir(path: &Path) -> io::Result<ReadDir> {
-    match split_path(path)? {
-        SplitPath::None => Ok(ReadDir::Tables(TableIter::new().map_err(cvt_err)?)),
-        SplitPath::Table { table } => {
-            let (table_id, table_info) = find_table(table)?;
-            let query = rt_io::query(table_id, &[]).map_err(cvt_err)?;
-            Ok(ReadDir::Objects { table_id, table_info, query })
-        }
-        SplitPath::Path { table, path } => {
-            let (table_id, table_info) = find_table(table)?;
-            let query = rt_io::query(table_id, path).map_err(cvt_err)?;
-            Ok(ReadDir::Objects { table_id, table_info, query })
-        }
-    }
+    rt_io::base_object().query(path_inner(path)).map(ReadDir).map_err(cvt_err)
 }
 
 pub fn unlink(_p: &Path) -> io::Result<()> {
@@ -385,10 +288,8 @@ pub fn link(_src: &Path, _dst: &Path) -> io::Result<()> {
     unsupported()
 }
 
-pub fn stat(path: &Path) -> io::Result<FileAttr> {
-    let _ = split_into_table_and_path(path)?;
-    // TODO stat doesn't actually exist yet though we do support FileAttr to some limited degree.
-    Ok(FileAttr::Object { size: 0 })
+pub fn stat(_path: &Path) -> io::Result<FileAttr> {
+    unsupported()
 }
 
 pub fn lstat(path: &Path) -> io::Result<FileAttr> {
@@ -403,71 +304,7 @@ pub fn copy(_from: &Path, _to: &Path) -> io::Result<u64> {
     unsupported()
 }
 
-/// Get table ID & info.
-fn find_table(name: &[u8]) -> io::Result<(TableId, TableInfo)> {
-    for entry in readdir(Path::new("")).unwrap().filter_map(Result::ok) {
-        match entry {
-            DirEntry::Table { id, info } => {
-                if info.name() == name {
-                    return Ok((id, info));
-                }
-            }
-            DirEntry::Object { .. } => unreachable!(),
-        }
-    }
-    Err(io::const_io_error!(io::ErrorKind::NotFound, "table not found"))
-}
-
-enum SplitPath<'a> {
-    None,
-    Table { table: &'a [u8] },
-    Path { table: &'a [u8], path: &'a [u8] },
-}
-
-/// Split a path by table, path and ID.
-fn split_path(path: &Path) -> io::Result<SplitPath<'_>> {
-    let path = path_inner(path);
-
-    if path.is_empty() {
-        return Ok(SplitPath::None);
-    }
-
-    fn split(s: &[u8], sep: u8) -> Option<(&[u8], &[u8])> {
-        s.iter().position(|c| *c == sep).map(|i| {
-            // TODO parse path
-            let (table, path) = s.split_at(i);
-            (table, &path[1..])
-        })
-    }
-
-    if let Some((table, path)) = split(path, TABLE_OBJECT_SEPARATOR) {
-        if path.is_empty() {
-            Ok(SplitPath::Table { table })
-        } else {
-            Ok(SplitPath::Path { table, path })
-        }
-    } else {
-        Ok(SplitPath::Table { table: path })
-    }
-}
-
 /// Get a reference to the underlying `[u8]` of a [`Path`].
 fn path_inner(path: &Path) -> &[u8] {
     &path.as_os_str().as_inner().inner
 }
-
-/// Split a path into a table and object component
-///
-/// # Errors
-///
-/// - There is no separator.
-/// - The table does not exist.
-fn split_into_table_and_path(path: &Path) -> io::Result<(TableId, &[u8])> {
-    // Find a unique ID
-    match split_path(path)? {
-        SplitPath::Path { path, table } => Ok((find_table(table)?.0, path)),
-        SplitPath::Table { .. } | SplitPath::None => {
-            Err(io::const_io_error!(io::ErrorKind::InvalidInput, "expected path and/or id"))
-        }
-    }
-}
diff --git a/library/std/src/sys/norostb/stdio.rs b/library/std/src/sys/norostb/stdio.rs
index 7265037b5a2..aff39df5492 100644
--- a/library/std/src/sys/norostb/stdio.rs
+++ b/library/std/src/sys/norostb/stdio.rs
@@ -67,18 +67,13 @@ pub fn panic_output() -> Option<impl io::Write> {
 ///
 /// Must be called only once during runtime initialization.
 pub(super) unsafe fn init() {
-    // Find the UART table
-    let mut tbl = None;
-    for (id, info) in rt::table::TableIter::new().unwrap() {
-        if info.name() == b"uart" {
-            tbl = Some(id);
-            break;
-        }
-    }
-    // If we couldn't find the table, there is absolutely nothing we can do, so just abort.
-    let tbl = tbl.unwrap_or_else(|| core::intrinsics::abort());
-
-    STDIN.store(rt::io::open(tbl, b"0").unwrap(), Ordering::Relaxed);
-    STDOUT.store(rt::io::open(tbl, b"0").unwrap(), Ordering::Relaxed);
-    STDERR.store(rt::io::open(tbl, b"0").unwrap(), Ordering::Relaxed);
+    let f = || {
+        rt::io::base_object()
+            .open(b"uart/0")
+            .unwrap_or_else(|_| core::intrinsics::abort())
+            .into_raw()
+    };
+    STDIN.store(f(), Ordering::Relaxed);
+    STDOUT.store(f(), Ordering::Relaxed);
+    STDERR.store(f(), Ordering::Relaxed);
 }
-- 
2.30.2

