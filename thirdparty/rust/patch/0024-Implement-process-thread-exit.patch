From 0b1a940b185d97331ffd2716e15ba72e3372cf76 Mon Sep 17 00:00:00 2001
From: David Hoppenbrouwers <david@salt-inc.org>
Date: Fri, 22 Apr 2022 00:50:28 +0200
Subject: [PATCH 24/45] Implement process & thread exit

---
 library/std/src/lib.rs                        |  1 +
 library/std/src/sys/norostb/common.rs         |  4 +-
 library/std/src/sys/norostb/os.rs             |  5 +-
 library/std/src/sys/norostb/process.rs        | 13 +++--
 library/std/src/sys/norostb/thread.rs         | 50 ++++++++++++++++---
 .../std/src/sys/norostb/thread_local_key.rs   | 16 ++++--
 6 files changed, 68 insertions(+), 21 deletions(-)

diff --git a/library/std/src/lib.rs b/library/std/src/lib.rs
index 5acce889961..30e647636a7 100644
--- a/library/std/src/lib.rs
+++ b/library/std/src/lib.rs
@@ -226,6 +226,7 @@
 #![feature(allow_internal_unstable)]
 #![feature(arbitrary_self_types)]
 #![feature(array_error_internals)]
+#![feature(asm_const)]
 #![feature(asm_sym)]
 #![feature(assert_matches)]
 #![feature(associated_type_bounds)]
diff --git a/library/std/src/sys/norostb/common.rs b/library/std/src/sys/norostb/common.rs
index 1db6a49a522..78eaf61d8b4 100644
--- a/library/std/src/sys/norostb/common.rs
+++ b/library/std/src/sys/norostb/common.rs
@@ -24,9 +24,7 @@ pub fn decode_error_kind(_code: i32) -> crate::io::ErrorKind {
 }
 
 pub fn abort_internal() -> ! {
-    unsafe {
-        crate::arch::asm!("hlt; hlt; hlt; ud2", options(noreturn));
-    }
+    super::os::exit(i32::MAX)
 }
 
 pub fn hashmap_random_keys() -> (u64, u64) {
diff --git a/library/std/src/sys/norostb/os.rs b/library/std/src/sys/norostb/os.rs
index e150ae143ad..1a7c370b58f 100644
--- a/library/std/src/sys/norostb/os.rs
+++ b/library/std/src/sys/norostb/os.rs
@@ -5,6 +5,7 @@
 use crate::io;
 use crate::marker::PhantomData;
 use crate::path::{self, PathBuf};
+use norostb_rt::kernel::syscall;
 
 pub fn errno() -> i32 {
     0
@@ -96,8 +97,8 @@ pub fn home_dir() -> Option<PathBuf> {
     None
 }
 
-pub fn exit(_code: i32) -> ! {
-    crate::intrinsics::abort()
+pub fn exit(code: i32) -> ! {
+    syscall::exit(code)
 }
 
 pub fn getpid() -> u32 {
diff --git a/library/std/src/sys/norostb/process.rs b/library/std/src/sys/norostb/process.rs
index 42a1ff730e3..f4874b3d196 100644
--- a/library/std/src/sys/norostb/process.rs
+++ b/library/std/src/sys/norostb/process.rs
@@ -8,6 +8,7 @@
 use crate::sys::pipe::AnonPipe;
 use crate::sys::unsupported;
 use crate::sys_common::process::{CommandEnv, CommandEnvs};
+use norostb_rt::kernel::io::Handle;
 
 pub use crate::ffi::OsString as EnvKey;
 
@@ -171,23 +172,25 @@ fn from(code: u8) -> Self {
     }
 }
 
-pub struct Process(!);
+pub struct Process {
+    handle: Handle,
+}
 
 impl Process {
     pub fn id(&self) -> u32 {
-        self.0
+        self.handle
     }
 
     pub fn kill(&mut self) -> io::Result<()> {
-        self.0
+        unsupported()
     }
 
     pub fn wait(&mut self) -> io::Result<ExitStatus> {
-        self.0
+        unsupported()
     }
 
     pub fn try_wait(&mut self) -> io::Result<Option<ExitStatus>> {
-        self.0
+        unsupported()
     }
 }
 
diff --git a/library/std/src/sys/norostb/thread.rs b/library/std/src/sys/norostb/thread.rs
index 50c3963d31d..806b093cbd7 100644
--- a/library/std/src/sys/norostb/thread.rs
+++ b/library/std/src/sys/norostb/thread.rs
@@ -5,10 +5,11 @@
 use crate::num::NonZeroUsize;
 use crate::ptr;
 use crate::time::Duration;
+use norostb_rt::kernel::io::Handle;
 use norostb_rt::kernel::syscall::{self, RWX};
 
 pub struct Thread {
-    handle: usize,
+    handle: Handle,
 }
 
 pub const DEFAULT_MIN_STACK_SIZE: usize = 4096;
@@ -28,7 +29,7 @@ pub unsafe fn new(stack: usize, p: Box<dyn FnOnce()>) -> io::Result<Thread> {
         let mut stack_ptr = stack_top;
         let mut push = |v: usize| {
             stack_ptr = stack_ptr.wrapping_sub(1);
-            // SAFETY: we will only push two usizes, which should fit well within a single
+            // SAFETY: we will only push four usizes, which should fit well within a single
             // page.
             unsafe {
                 stack_ptr.write(v);
@@ -36,8 +37,16 @@ pub unsafe fn new(stack: usize, p: Box<dyn FnOnce()>) -> io::Result<Thread> {
         };
         push(ptr as usize);
         push(unsafe { mem::transmute(meta) });
+        push(stack.as_ptr() as usize);
+        push(stack_size.get());
 
-        unsafe extern "C" fn main(ptr: *mut (), meta: usize) -> ! {
+        unsafe extern "C" fn main(
+            ptr: *mut (),
+            meta: usize,
+            stack_base: *const (),
+            stack_size: usize,
+            handle: Handle,
+        ) -> ! {
             let meta = unsafe { mem::transmute(meta) };
             let p: Box<dyn FnOnce()> = unsafe { Box::from_raw(ptr::from_raw_parts_mut(ptr, meta)) };
 
@@ -47,8 +56,29 @@ pub unsafe fn new(stack: usize, p: Box<dyn FnOnce()>) -> io::Result<Thread> {
 
             p();
 
-            loop {
-                syscall::sleep(crate::time::Duration::MAX);
+            unsafe {
+                super::thread_local_key::deinit_thread();
+            }
+
+            // We're going to free the stack, so we need to resort to assembly
+            unsafe {
+                core::arch::asm!(
+                    // Deallocate stack
+                    "syscall",
+                    // Kill current thread
+                    "mov eax, {kill_thread}",
+                    "mov rdi, {handle}",
+                    "syscall",
+                    kill_thread = const syscall::ID_KILL_THREAD,
+                    // "formatting may not be suitable for sub-register argument" ???
+                    // Hence cast to usize
+                    handle = in(reg) handle as usize,
+                    in("eax") syscall::ID_DEALLOC,
+                    in("rdi") stack_base,
+                    in("rsi") stack_size,
+                    in("rdx") 0,
+                    options(noreturn, nostack),
+                );
             }
         }
 
@@ -58,6 +88,9 @@ pub unsafe fn new(stack: usize, p: Box<dyn FnOnce()>) -> io::Result<Thread> {
                 crate::arch::asm!("
 					mov rdi, [rsp - 8 * 1]
 					mov rsi, [rsp - 8 * 2]
+					mov rdx, [rsp - 8 * 3]
+					mov rcx, [rsp - 8 * 4]
+					mov r8d, eax
 					jmp {main}
 					",
                     main = sym main,
@@ -69,7 +102,10 @@ pub unsafe fn new(stack: usize, p: Box<dyn FnOnce()>) -> io::Result<Thread> {
         // Spawn thread
         unsafe {
             syscall::spawn_thread(start, stack_top as *const ())
-                .map_err(|_| io::const_io_error!(io::ErrorKind::Other, "failed to spawn thread"))
+                .map_err(|_| {
+                    syscall::dealloc(stack.cast(), stack_size.get(), false, false).unwrap();
+                    io::const_io_error!(io::ErrorKind::Other, "failed to spawn thread")
+                })
                 .map(|handle| Self { handle })
         }
     }
@@ -87,7 +123,7 @@ pub fn sleep(dur: Duration) {
     }
 
     pub fn join(self) {
-        todo!("join thread {}", self.handle);
+        let _ = syscall::wait_thread(self.handle);
     }
 }
 
diff --git a/library/std/src/sys/norostb/thread_local_key.rs b/library/std/src/sys/norostb/thread_local_key.rs
index 0513f6c5bd4..55333804ce6 100644
--- a/library/std/src/sys/norostb/thread_local_key.rs
+++ b/library/std/src/sys/norostb/thread_local_key.rs
@@ -11,11 +11,19 @@
 /// This must be called exactly once when a thread is created.
 pub(super) unsafe fn init_thread() {
     unsafe {
-        tls::init_thread::<_, ()>(|s| {
-            Ok(NonNull::new(Box::into_raw(Box::<[u8]>::new_uninit_slice(s)) as *mut *mut ())
-                .unwrap())
+        tls::init_thread(|s| {
+            NonNull::new(Box::into_raw(Box::<[u8]>::new_uninit_slice(s)) as *mut [u8]).unwrap()
+        })
+    }
+}
+/// # Safety
+///
+/// This must be called exactly once when a thread is created.
+pub(super) unsafe fn deinit_thread() {
+    unsafe {
+        tls::deinit_thread(|p| {
+            Box::from_raw(p.as_ptr());
         })
-        .unwrap_or_else(|_| crate::intrinsics::abort())
     }
 }
 
-- 
2.30.2

